// lib/src/game_state/game_state.dart
// Utilities: a thin GameState wrapper to maintain history, detect threefold/fifty-move,
// record PGN moves and handle agreement/resign/timeout.
//
// Depends on package:dartchess
// Add to package exports if you want it public: `export 'src/game_state/game_state.dart';`

import 'dart:math';

import 'package:dartchess/dartchess.dart';
import 'package:flutter/material.dart';

import '../../domain/models/chess_game.dart';

/// A lightweight mutable controller for a game built on top of dartchess immutable Position.
/// - Keeps fenHistory and fenCounts for repetition detection.
/// - Records moves to a PGN tree (PgnNode/PgnChildNode).
/// - Provides game-level actions: agreement draw, resign, timeout.
class GameState {
  /// Current immutable position.
  Position _pos;

  /// Full FEN history (one entry per position after each move, includes initial).
  final List<String> fenHistory = [];

  /// Normalized FEN â†’ count (normalized = board + turn + castling + ep)
  final Map<String, int> fenCounts = {};

  /// PGN moves as a mutable tree.
  final PgnNode<PgnNodeData> pgnRoot = PgnNode<PgnNodeData>();
  // Linear move list (no variations). Each entry stores SAN, optional comment and NAGs.
  final List<MoveData> _moves = [];

  // redo stacks
  final List<String> _redoFenStack = [];
  final List<MoveData> _redoMoveStack = [];

  /// Result/outcome of the game (null if not finished).
  Outcome? result;

  /// If non-null, this side resigned.
  Side? resignationSide;

  /// Whether players agreed to a draw.
  bool agreementFlag = false;

  /// If non-null, this side timed out.
  Side? timeoutSide;

  /// Create GameState with an initial Position (defaults to standard initial).
  GameState({Position? initial}) : _pos = initial ?? Chess.initial {
    _pushPosition(_pos);
  }

  /// Current position (immutable).
  Position get position => _pos;

  Side get turn => _pos.turn;

  /// Normalize FEN for repetition: keep board, turn, castling, en-passant only.
  // ignore: unintended_html_in_doc_comment
  /// FEN format: "<board> <turn> <castling> <ep> <halfmoves> <fullmoves>"
  static String normalizeFen(String fen) {
    final parts = fen.split(' ');
    if (parts.length < 4) return fen;
    return '${parts[0]} ${parts[1]} ${parts[2]} ${parts[3]}';
  }

  /// Static helper: normalize a PGN string by removing all variations wrapped in parentheses.
  /// Removes nested variations as well by repeatedly stripping innermost "(...)" groups.
  /// Useful when a PGN producer inserts variations but you want a flat linear PGN.
  static String normalizePgn(String pgn) {
    // Remove any parentheses groups iteratively from innermost to outermost.
    var output = pgn;
    final re = RegExp(r'\([^()]*\)');
    while (re.hasMatch(output)) {
      output = output.replaceAll(re, '');
    }
    // Collapse multiple spaces produced by removals, then trim.
    //TODO
    // output = output.replaceAll(RegExp(r'\s'), ' ').trim();
    output = output.replaceAll(RegExp(r'\s+'), ' ').trim();
    return output;
  }

  void _pushPosition(Position pos) {
    final fen = pos.fen;
    fenHistory.add(fen);
    final key = GameState.normalizeFen(fen);
    debugPrint("normalizeFen: $key");
    fenCounts[key] = (fenCounts[key] ?? 0) + 1;
  }

  void _popPosition(Position pos) {
    final fen = pos.fen;
    final key = GameState.normalizeFen(fen);
    // decrement fenCounts for removed fen
    final prevCount = (fenCounts[key] ?? 1) - 1;
    if (prevCount <= 0) {
      fenCounts.remove(key);
    } else {
      fenCounts[key] = prevCount;
    }
  }

  /// Play a move and optionally attach a comment and NAGs.
  ///
  /// - [move]: a Move object parsed from SAN or generated by the API.
  /// - [comment]: optional PGN comment string (will be wrapped with `{ }` in PGN).
  /// - [nags]: optional list of NAG numbers (e.g. [1, 3] will be rendered as `$1 $3` after SAN).
  ///
  /// Note: uses Position.makeSan(move) -> (Position, String) record to compute SAN and new position.
  void play(Move move, {String? comment, List<int>? nags}) {
    final record = _pos.makeSan(move);
    final Position newPos = record.$1;
    final String san = record.$2;

    // when playing a new move after undo, clear redo stacks
    if (_redoFenStack.isNotEmpty || _redoMoveStack.isNotEmpty) {
      _redoFenStack.clear();
      _redoMoveStack.clear();
    }

    _pos = newPos;
    _pushPosition(_pos);
    _moves.add(
      MoveData()
        ..san = san
        ..comment = comment
        ..nags = nags,
    );
    if (_pos.isGameOver) {
      result = _pos.outcome;
    }
    // if (isCheckmate) {
    //   result = Outcome(
    //     winner: _pos.turn == Side.white ? Side.black : Side.white,
    //   );
    // } else if (isDraw) {
    //   result = Outcome.draw;
    // }
  }

  /// Return true if current position has occurred 3 or more times.
  bool isThreefoldRepetition() {
    // 1. EndGame  isThreefoldRepetition
    final key = GameState.normalizeFen(_pos.fen);
    final cnt = fenCounts[key] ?? 0;
    return cnt >= 3;
  }

  /// Getter for half-move clock (since last pawn move or capture).
  /// Uses the immutable position's value (accurate to the current position).
  int get halfmoveClock => _pos.halfmoves; // 2. EndGame  halfmoveClock

  /// Fifty-move rule: 100 halfmoves (50 full moves) since capture/pawn move.
  bool isFiftyMoveRule() {
    // 2. EndGame  isFiftyMoveRule
    return halfmoveClock >= 100;
  }

  /// Agreement draw: set result to draw.
  void setAgreementDraw() {
    agreementFlag = true;
    result = Outcome.draw;
  }

  bool isAgreedDraw() => agreementFlag; // 3. EndGame  isAgreedDraw

  /// Resign: if side resigns, winner is the other side.
  void resign(Side side) {
    resignationSide = side;
    final winner = side == Side.white ? Side.black : Side.white;
    result = Outcome(winner: winner);
  }

  bool isResigned() => resignationSide != null; // 4. EndGame  isResigned

  /// Timeout: side timed out; winner is other side (caller handles tournament rules).
  void timeout(Side side) {
    timeoutSide = side;
    final winner = side == Side.white ? Side.black : Side.white;
    result = Outcome(winner: winner);
  }

  bool isTimeout() => timeoutSide != null; // 5. EndGame  isTimeout

  bool get isInsufficientMaterial =>
      _pos.isInsufficientMaterial; // 6. EndGame  isInsufficientMaterial

  bool get isStalemate => _pos.isStalemate; // 7. EndGame  isStalemate

  bool get isCheck => _pos.isCheck;

  bool get isCheckmate => _pos.isCheckmate; // 8. EndGame  isCheckmate

  bool get isGameOver => _pos.isGameOver;

  ///
  bool get isGameOverExtended => isMate || isDraw;

  ///
  bool get isDraw =>
      isFiftyMoveRule() ||
      isThreefoldRepetition() ||
      isAgreedDraw() ||
      isStalemate ||
      isInsufficientMaterial;

  ///
  bool get isMate => isCheckmate || isResigned() || isTimeout();

  // bool hasInsufficientMaterial(Side side) {
  //   return _pos.hasInsufficientMaterial(side);
  // }

  // ----------------------------
  /// Returns map of pieces captured *by* [side] (i.e., opponent lost these).
  // Captures / material evaluation
  // ----------------------------
  Map<Role, int> getCapturedPieces(Side side) {
    final opposite = side == Side.white ? Side.black : Side.white;
    final opponentCounts = _pos.board.materialCount(opposite);
    final Map<Role, int> initial = {
      Role.pawn: 8,
      Role.knight: 2,
      Role.bishop: 2,
      Role.rook: 2,
      Role.queen: 1,
      Role.king: 1,
    };
    final Map<Role, int> captured = {};
    for (final r in initial.keys) {
      captured[r] = (initial[r] ?? 0) - (opponentCounts[r] ?? 0);
    }
    return captured;
  }

  /// Human-readable representation for captured pieces (e.g. "pawn x1, rook x1").
  String capturedPiecesAsString(Side side) {
    final caps = getCapturedPieces(side);
    final List<String> parts = [];
    caps.forEach((role, cnt) {
      if (cnt > 0) parts.add('${role.name} x$cnt');
    });
    return parts.isEmpty ? '-' : parts.join(', ');
  }

  /// Simple material evaluation in centipawns (White minus Black).
  /// Weights used: pawn=100, knight=300, bishop=300, rook=500, queen=900.
  int materialEvaluationCentipawns() {
    final weights = {
      Role.pawn: 100,
      Role.knight: 300,
      Role.bishop: 300,
      Role.rook: 500,
      Role.queen: 900,
      Role.king: 0,
    };
    final whiteCounts = _pos.board.materialCount(Side.white);
    final blackCounts = _pos.board.materialCount(Side.black);
    int wsum = 0, bsum = 0;
    for (final r in weights.keys) {
      final w = weights[r]!;
      wsum += (whiteCounts[r] ?? 0) * w;
      bsum += (blackCounts[r] ?? 0) * w;
    }
    return wsum - bsum;
  }

  // ----------------------------
  // PGN building
  /// Build PGN string manually (linear moves), including NAGs and comments.
  /// headers: map of PGN headers (Event, Site, Date, White, Black, Result, ...).
  /// The Result header is filled from current result if present.
  // ----------------------------
  String pgnString({Map<String, String>? headers}) {
    final Map<String, String> baseHeaders = {
      'Event': 'Casual Game',
      'Site': '?',
      'Date': _todayDateString(),
      'Round': '?',
      'White': 'White',
      'Black': 'Black',
      'Result': _resultToPgnString(result),
    };
    if (headers != null) baseHeaders.addAll(headers);

    final sb = StringBuffer();
    baseHeaders.forEach((k, v) {
      sb.writeln('[$k "$v"]');
    });
    sb.writeln();

    // build move text
    final List<String> tokens = [];
    for (var i = 0; i < _moves.length; i++) {
      final move = _moves[i];
      final isWhite = (i % 2 == 0);
      if (isWhite) {
        final moveNumber = (i ~/ 2) + 1;
        tokens.add('$moveNumber.');
      }
      // SAN
      final List<String> pieceTokens = [];
      pieceTokens.add(move.san!);
      // NAGs as $n
      if (move.nags != null && move.nags!.isNotEmpty) {
        pieceTokens.addAll(move.nags!.map((n) => '\$$n'));
      }
      // comment as { ... }
      if (move.comment != null && move.comment!.isNotEmpty) {
        pieceTokens.add('{ ${_escapeComment(move.comment!)} }');
      }
      tokens.add(pieceTokens.join(' '));
    }

    sb.writeln(tokens.join(' '));
    // ensure result appended (if null -> *)
    sb.write(baseHeaders['Result']);
    return sb.toString();
  }

  String _todayDateString() {
    final d = DateTime.now().toUtc();
    return '${d.year.toString().padLeft(4, '0')}.${d.month.toString().padLeft(2, '0')}.${d.day.toString().padLeft(2, '0')}';
  }

  String _escapeComment(String c) {
    // minimal escaping: replace '}' with '\}' to avoid closing comment early.
    return c.replaceAll('}', '\\}');
  }

  /// material score in pawns (centipawns / 100) as double (positive = White advantage).
  double materialScore() => materialEvaluationCentipawns() / 100.0;

  String _resultToPgnString(Outcome? r) {
    if (r == null) return '*';

    if (r == Outcome.draw) return '1/2-1/2';
    final w = r.winner;
    if (w == Side.white) return '1-0';
    if (w == Side.black) return '0-1';
    return '*';
  }

  bool get canUndo => _moves.isNotEmpty || !(fenHistory.length <= 1);

  // ----------------------------
  // Undo / Redo
  // ----------------------------
  /// Undo the last move. Returns true if undone.
  bool undoMove() {
    if (!canUndo) return false;
    // pop last move and fen
    final lastFen = fenHistory.removeLast(); // current position fen removed
    final lastMove = _moves.removeLast();

    // push to redo stacks so we can redo later
    _redoFenStack.add(lastFen);
    _redoMoveStack.add(lastMove);

    _popPosition(_pos);
    // set position to new last fen (previous position)
    final prevFen = fenHistory.last;
    _pos = Chess.fromSetup(Setup.parseFen(prevFen));

    // clear result/resignation/timeout if any (because we rolled back)
    result = null;
    resignationSide = null;
    timeoutSide = null;
    agreementFlag = false;

    return true;
  }

  bool get canRedo => _redoFenStack.isNotEmpty || _redoMoveStack.isNotEmpty;

  /// Redo previously undone move. Returns true if redone.
  bool redoMove() {
    if (!canRedo) return false;
    final fen = _redoFenStack.removeLast();
    final move = _redoMoveStack.removeLast();
    // apply fen and move into history
    
    // restore position
    _pos = Chess.fromSetup(Setup.parseFen(fen));
    _pushPosition(_pos);

    _moves.add(move);

    // if position is terminal, set result
    if (_pos.isGameOver) {
      result = _pos.outcome;
    }

    return true;
  }
}

/// Main GameState controller.
extension GameStatee on GameState {
  /// Simple positional evaluation: material + mobility + bishop pair + small center control.
  /// Returns centipawns (positive means White advantage).
  int evaluateCentipawns() {
    final material = materialEvaluationCentipawns();

    // mobility: number of legal moves difference * factor
    final movesLength = _pos.legalMoves.length;
    final whiteMoves = _pos.turn == Side.white ? movesLength : 0;
    final blackMoves = _pos.turn == Side.black ? movesLength : 0;
    final mobilityDiff = (whiteMoves - blackMoves);
    final mobilityScore = mobilityDiff * 5; // 5 cp per legal move advantage

    // bishop pair bonus
    final whiteCounts = _pos.board.materialCount(Side.white);
    final blackCounts = _pos.board.materialCount(Side.black);
    int bishopPair = 0;
    if ((whiteCounts[Role.bishop] ?? 0) >= 2) bishopPair += 50;
    if ((blackCounts[Role.bishop] ?? 0) >= 2) bishopPair -= 50;

    // small center pawns bonus: count pawns on d/e files
    int centerPawnScore = 0;
    centerPawnScore += _countPawnsOnFiles(Side.white, ['d', 'e']) * 10;
    centerPawnScore -= _countPawnsOnFiles(Side.black, ['d', 'e']) * 10;

    return material + mobilityScore + bishopPair + centerPawnScore;
  }

  int _countPawnsOnFiles(Side side, List<String> files) {
    var count = 0;
    // iterate over board squares A1..H8; use roleAt to detect pawns
    for (final sq in Square.values) {
      final role = _pos.board.roleAt(sq);
      final s = _pos.board.sideAt(sq);
      if (role == Role.pawn && s == side) {
        final fileChar = sq.toString().toLowerCase(); // depends on enum naming
        // Fallback: we can compute file by sq.index % 8 but this depends on library
        // To be robust, match by algebraic notation if available:
        final alg = sq.toString(); // adjust if needed
        for (final f in files) {
          if (alg.contains(f)) count++;
        }
      }
    }
    return count;
  }

  /// Return approximate win probability for White from centipawn advantage.
  /// Uses logistic-like mapping (approximation).
  double centipawnToWinProbability(int cp) {
    final exponent = -cp / 400.0;
    return 1.0 / (1.0 + pow(10, exponent));
  }

  /// ELO helper: expected score for player A against B.
  static double eloExpected(int ratingA, int ratingB) {
    return 1.0 / (1.0 + pow(10.0, (ratingB - ratingA) / 400.0));
  }

  /// Update rating for player A. score = 1, 0.5, 0
  static int eloUpdate(int ratingA, int ratingB, double score, {int k = 20}) {
    final expect = eloExpected(ratingA, ratingB);
    final newRating = ratingA + (score - expect) * k;
    return newRating.round();
  }
}
