// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'move_data_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

MoveDataModel _$MoveDataModelFromJson(Map<String, dynamic> json) {
  return _MoveDataModel.fromJson(json);
}

/// @nodoc
mixin _$MoveDataModel {
  String? get san => throw _privateConstructorUsedError;
  String? get lan => throw _privateConstructorUsedError;
  String? get comment => throw _privateConstructorUsedError;
  List<int> get nags =>
      throw _privateConstructorUsedError; // يجب جعلها غير اختيارية مع قيمة افتراضية لـ JSON
  String? get fenAfter => throw _privateConstructorUsedError;
  List<String> get variations =>
      throw _privateConstructorUsedError; // يجب جعلها غير اختيارية مع قيمة افتراضية
  bool get wasCapture => throw _privateConstructorUsedError;
  bool get wasCheck => throw _privateConstructorUsedError;
  bool get wasCheckmate => throw _privateConstructorUsedError;
  bool get wasPromotion => throw _privateConstructorUsedError;
  bool? get isWhiteMove => throw _privateConstructorUsedError;
  int? get halfmoveIndex => throw _privateConstructorUsedError;
  int? get moveNumber => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MoveDataModelCopyWith<MoveDataModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MoveDataModelCopyWith<$Res> {
  factory $MoveDataModelCopyWith(
          MoveDataModel value, $Res Function(MoveDataModel) then) =
      _$MoveDataModelCopyWithImpl<$Res, MoveDataModel>;
  @useResult
  $Res call(
      {String? san,
      String? lan,
      String? comment,
      List<int> nags,
      String? fenAfter,
      List<String> variations,
      bool wasCapture,
      bool wasCheck,
      bool wasCheckmate,
      bool wasPromotion,
      bool? isWhiteMove,
      int? halfmoveIndex,
      int? moveNumber});
}

/// @nodoc
class _$MoveDataModelCopyWithImpl<$Res, $Val extends MoveDataModel>
    implements $MoveDataModelCopyWith<$Res> {
  _$MoveDataModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? san = freezed,
    Object? lan = freezed,
    Object? comment = freezed,
    Object? nags = null,
    Object? fenAfter = freezed,
    Object? variations = null,
    Object? wasCapture = null,
    Object? wasCheck = null,
    Object? wasCheckmate = null,
    Object? wasPromotion = null,
    Object? isWhiteMove = freezed,
    Object? halfmoveIndex = freezed,
    Object? moveNumber = freezed,
  }) {
    return _then(_value.copyWith(
      san: freezed == san
          ? _value.san
          : san // ignore: cast_nullable_to_non_nullable
              as String?,
      lan: freezed == lan
          ? _value.lan
          : lan // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      nags: null == nags
          ? _value.nags
          : nags // ignore: cast_nullable_to_non_nullable
              as List<int>,
      fenAfter: freezed == fenAfter
          ? _value.fenAfter
          : fenAfter // ignore: cast_nullable_to_non_nullable
              as String?,
      variations: null == variations
          ? _value.variations
          : variations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      wasCapture: null == wasCapture
          ? _value.wasCapture
          : wasCapture // ignore: cast_nullable_to_non_nullable
              as bool,
      wasCheck: null == wasCheck
          ? _value.wasCheck
          : wasCheck // ignore: cast_nullable_to_non_nullable
              as bool,
      wasCheckmate: null == wasCheckmate
          ? _value.wasCheckmate
          : wasCheckmate // ignore: cast_nullable_to_non_nullable
              as bool,
      wasPromotion: null == wasPromotion
          ? _value.wasPromotion
          : wasPromotion // ignore: cast_nullable_to_non_nullable
              as bool,
      isWhiteMove: freezed == isWhiteMove
          ? _value.isWhiteMove
          : isWhiteMove // ignore: cast_nullable_to_non_nullable
              as bool?,
      halfmoveIndex: freezed == halfmoveIndex
          ? _value.halfmoveIndex
          : halfmoveIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      moveNumber: freezed == moveNumber
          ? _value.moveNumber
          : moveNumber // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MoveDataModelImplCopyWith<$Res>
    implements $MoveDataModelCopyWith<$Res> {
  factory _$$MoveDataModelImplCopyWith(
          _$MoveDataModelImpl value, $Res Function(_$MoveDataModelImpl) then) =
      __$$MoveDataModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? san,
      String? lan,
      String? comment,
      List<int> nags,
      String? fenAfter,
      List<String> variations,
      bool wasCapture,
      bool wasCheck,
      bool wasCheckmate,
      bool wasPromotion,
      bool? isWhiteMove,
      int? halfmoveIndex,
      int? moveNumber});
}

/// @nodoc
class __$$MoveDataModelImplCopyWithImpl<$Res>
    extends _$MoveDataModelCopyWithImpl<$Res, _$MoveDataModelImpl>
    implements _$$MoveDataModelImplCopyWith<$Res> {
  __$$MoveDataModelImplCopyWithImpl(
      _$MoveDataModelImpl _value, $Res Function(_$MoveDataModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? san = freezed,
    Object? lan = freezed,
    Object? comment = freezed,
    Object? nags = null,
    Object? fenAfter = freezed,
    Object? variations = null,
    Object? wasCapture = null,
    Object? wasCheck = null,
    Object? wasCheckmate = null,
    Object? wasPromotion = null,
    Object? isWhiteMove = freezed,
    Object? halfmoveIndex = freezed,
    Object? moveNumber = freezed,
  }) {
    return _then(_$MoveDataModelImpl(
      san: freezed == san
          ? _value.san
          : san // ignore: cast_nullable_to_non_nullable
              as String?,
      lan: freezed == lan
          ? _value.lan
          : lan // ignore: cast_nullable_to_non_nullable
              as String?,
      comment: freezed == comment
          ? _value.comment
          : comment // ignore: cast_nullable_to_non_nullable
              as String?,
      nags: null == nags
          ? _value._nags
          : nags // ignore: cast_nullable_to_non_nullable
              as List<int>,
      fenAfter: freezed == fenAfter
          ? _value.fenAfter
          : fenAfter // ignore: cast_nullable_to_non_nullable
              as String?,
      variations: null == variations
          ? _value._variations
          : variations // ignore: cast_nullable_to_non_nullable
              as List<String>,
      wasCapture: null == wasCapture
          ? _value.wasCapture
          : wasCapture // ignore: cast_nullable_to_non_nullable
              as bool,
      wasCheck: null == wasCheck
          ? _value.wasCheck
          : wasCheck // ignore: cast_nullable_to_non_nullable
              as bool,
      wasCheckmate: null == wasCheckmate
          ? _value.wasCheckmate
          : wasCheckmate // ignore: cast_nullable_to_non_nullable
              as bool,
      wasPromotion: null == wasPromotion
          ? _value.wasPromotion
          : wasPromotion // ignore: cast_nullable_to_non_nullable
              as bool,
      isWhiteMove: freezed == isWhiteMove
          ? _value.isWhiteMove
          : isWhiteMove // ignore: cast_nullable_to_non_nullable
              as bool?,
      halfmoveIndex: freezed == halfmoveIndex
          ? _value.halfmoveIndex
          : halfmoveIndex // ignore: cast_nullable_to_non_nullable
              as int?,
      moveNumber: freezed == moveNumber
          ? _value.moveNumber
          : moveNumber // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MoveDataModelImpl implements _MoveDataModel {
  const _$MoveDataModelImpl(
      {this.san,
      this.lan,
      this.comment,
      final List<int> nags = const [],
      this.fenAfter,
      final List<String> variations = const [],
      this.wasCapture = false,
      this.wasCheck = false,
      this.wasCheckmate = false,
      this.wasPromotion = false,
      this.isWhiteMove,
      this.halfmoveIndex,
      this.moveNumber})
      : _nags = nags,
        _variations = variations;

  factory _$MoveDataModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$MoveDataModelImplFromJson(json);

  @override
  final String? san;
  @override
  final String? lan;
  @override
  final String? comment;
  final List<int> _nags;
  @override
  @JsonKey()
  List<int> get nags {
    if (_nags is EqualUnmodifiableListView) return _nags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_nags);
  }

// يجب جعلها غير اختيارية مع قيمة افتراضية لـ JSON
  @override
  final String? fenAfter;
  final List<String> _variations;
  @override
  @JsonKey()
  List<String> get variations {
    if (_variations is EqualUnmodifiableListView) return _variations;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_variations);
  }

// يجب جعلها غير اختيارية مع قيمة افتراضية
  @override
  @JsonKey()
  final bool wasCapture;
  @override
  @JsonKey()
  final bool wasCheck;
  @override
  @JsonKey()
  final bool wasCheckmate;
  @override
  @JsonKey()
  final bool wasPromotion;
  @override
  final bool? isWhiteMove;
  @override
  final int? halfmoveIndex;
  @override
  final int? moveNumber;

  @override
  String toString() {
    return 'MoveDataModel(san: $san, lan: $lan, comment: $comment, nags: $nags, fenAfter: $fenAfter, variations: $variations, wasCapture: $wasCapture, wasCheck: $wasCheck, wasCheckmate: $wasCheckmate, wasPromotion: $wasPromotion, isWhiteMove: $isWhiteMove, halfmoveIndex: $halfmoveIndex, moveNumber: $moveNumber)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MoveDataModelImpl &&
            (identical(other.san, san) || other.san == san) &&
            (identical(other.lan, lan) || other.lan == lan) &&
            (identical(other.comment, comment) || other.comment == comment) &&
            const DeepCollectionEquality().equals(other._nags, _nags) &&
            (identical(other.fenAfter, fenAfter) ||
                other.fenAfter == fenAfter) &&
            const DeepCollectionEquality()
                .equals(other._variations, _variations) &&
            (identical(other.wasCapture, wasCapture) ||
                other.wasCapture == wasCapture) &&
            (identical(other.wasCheck, wasCheck) ||
                other.wasCheck == wasCheck) &&
            (identical(other.wasCheckmate, wasCheckmate) ||
                other.wasCheckmate == wasCheckmate) &&
            (identical(other.wasPromotion, wasPromotion) ||
                other.wasPromotion == wasPromotion) &&
            (identical(other.isWhiteMove, isWhiteMove) ||
                other.isWhiteMove == isWhiteMove) &&
            (identical(other.halfmoveIndex, halfmoveIndex) ||
                other.halfmoveIndex == halfmoveIndex) &&
            (identical(other.moveNumber, moveNumber) ||
                other.moveNumber == moveNumber));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      san,
      lan,
      comment,
      const DeepCollectionEquality().hash(_nags),
      fenAfter,
      const DeepCollectionEquality().hash(_variations),
      wasCapture,
      wasCheck,
      wasCheckmate,
      wasPromotion,
      isWhiteMove,
      halfmoveIndex,
      moveNumber);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MoveDataModelImplCopyWith<_$MoveDataModelImpl> get copyWith =>
      __$$MoveDataModelImplCopyWithImpl<_$MoveDataModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MoveDataModelImplToJson(
      this,
    );
  }
}

abstract class _MoveDataModel implements MoveDataModel {
  const factory _MoveDataModel(
      {final String? san,
      final String? lan,
      final String? comment,
      final List<int> nags,
      final String? fenAfter,
      final List<String> variations,
      final bool wasCapture,
      final bool wasCheck,
      final bool wasCheckmate,
      final bool wasPromotion,
      final bool? isWhiteMove,
      final int? halfmoveIndex,
      final int? moveNumber}) = _$MoveDataModelImpl;

  factory _MoveDataModel.fromJson(Map<String, dynamic> json) =
      _$MoveDataModelImpl.fromJson;

  @override
  String? get san;
  @override
  String? get lan;
  @override
  String? get comment;
  @override
  List<int> get nags;
  @override // يجب جعلها غير اختيارية مع قيمة افتراضية لـ JSON
  String? get fenAfter;
  @override
  List<String> get variations;
  @override // يجب جعلها غير اختيارية مع قيمة افتراضية
  bool get wasCapture;
  @override
  bool get wasCheck;
  @override
  bool get wasCheckmate;
  @override
  bool get wasPromotion;
  @override
  bool? get isWhiteMove;
  @override
  int? get halfmoveIndex;
  @override
  int? get moveNumber;
  @override
  @JsonKey(ignore: true)
  _$$MoveDataModelImplCopyWith<_$MoveDataModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
