// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'general_preferences.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BackgroundImage {
  /// The path to the image asset relative to the document directory returned by [getApplicationDocumentsDirectory]
  String get path => throw _privateConstructorUsedError;
  Matrix4 get transform => throw _privateConstructorUsedError;
  bool get isBlurred => throw _privateConstructorUsedError;
  Color get seedColor => throw _privateConstructorUsedError;
  double get meanLuminance => throw _privateConstructorUsedError;
  double get width => throw _privateConstructorUsedError;
  double get height => throw _privateConstructorUsedError;
  double get viewportWidth => throw _privateConstructorUsedError;
  double get viewportHeight => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BackgroundImageCopyWith<BackgroundImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BackgroundImageCopyWith<$Res> {
  factory $BackgroundImageCopyWith(
          BackgroundImage value, $Res Function(BackgroundImage) then) =
      _$BackgroundImageCopyWithImpl<$Res, BackgroundImage>;
  @useResult
  $Res call(
      {String path,
      Matrix4 transform,
      bool isBlurred,
      Color seedColor,
      double meanLuminance,
      double width,
      double height,
      double viewportWidth,
      double viewportHeight});
}

/// @nodoc
class _$BackgroundImageCopyWithImpl<$Res, $Val extends BackgroundImage>
    implements $BackgroundImageCopyWith<$Res> {
  _$BackgroundImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? transform = null,
    Object? isBlurred = null,
    Object? seedColor = null,
    Object? meanLuminance = null,
    Object? width = null,
    Object? height = null,
    Object? viewportWidth = null,
    Object? viewportHeight = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      transform: null == transform
          ? _value.transform
          : transform // ignore: cast_nullable_to_non_nullable
              as Matrix4,
      isBlurred: null == isBlurred
          ? _value.isBlurred
          : isBlurred // ignore: cast_nullable_to_non_nullable
              as bool,
      seedColor: null == seedColor
          ? _value.seedColor
          : seedColor // ignore: cast_nullable_to_non_nullable
              as Color,
      meanLuminance: null == meanLuminance
          ? _value.meanLuminance
          : meanLuminance // ignore: cast_nullable_to_non_nullable
              as double,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
      viewportWidth: null == viewportWidth
          ? _value.viewportWidth
          : viewportWidth // ignore: cast_nullable_to_non_nullable
              as double,
      viewportHeight: null == viewportHeight
          ? _value.viewportHeight
          : viewportHeight // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BackgroundImageImplCopyWith<$Res>
    implements $BackgroundImageCopyWith<$Res> {
  factory _$$BackgroundImageImplCopyWith(_$BackgroundImageImpl value,
          $Res Function(_$BackgroundImageImpl) then) =
      __$$BackgroundImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String path,
      Matrix4 transform,
      bool isBlurred,
      Color seedColor,
      double meanLuminance,
      double width,
      double height,
      double viewportWidth,
      double viewportHeight});
}

/// @nodoc
class __$$BackgroundImageImplCopyWithImpl<$Res>
    extends _$BackgroundImageCopyWithImpl<$Res, _$BackgroundImageImpl>
    implements _$$BackgroundImageImplCopyWith<$Res> {
  __$$BackgroundImageImplCopyWithImpl(
      _$BackgroundImageImpl _value, $Res Function(_$BackgroundImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
    Object? transform = null,
    Object? isBlurred = null,
    Object? seedColor = null,
    Object? meanLuminance = null,
    Object? width = null,
    Object? height = null,
    Object? viewportWidth = null,
    Object? viewportHeight = null,
  }) {
    return _then(_$BackgroundImageImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      transform: null == transform
          ? _value.transform
          : transform // ignore: cast_nullable_to_non_nullable
              as Matrix4,
      isBlurred: null == isBlurred
          ? _value.isBlurred
          : isBlurred // ignore: cast_nullable_to_non_nullable
              as bool,
      seedColor: null == seedColor
          ? _value.seedColor
          : seedColor // ignore: cast_nullable_to_non_nullable
              as Color,
      meanLuminance: null == meanLuminance
          ? _value.meanLuminance
          : meanLuminance // ignore: cast_nullable_to_non_nullable
              as double,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
      viewportWidth: null == viewportWidth
          ? _value.viewportWidth
          : viewportWidth // ignore: cast_nullable_to_non_nullable
              as double,
      viewportHeight: null == viewportHeight
          ? _value.viewportHeight
          : viewportHeight // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$BackgroundImageImpl extends _BackgroundImage
    with DiagnosticableTreeMixin {
  const _$BackgroundImageImpl(
      {required this.path,
      required this.transform,
      required this.isBlurred,
      required this.seedColor,
      required this.meanLuminance,
      required this.width,
      required this.height,
      required this.viewportWidth,
      required this.viewportHeight})
      : super._();

  /// The path to the image asset relative to the document directory returned by [getApplicationDocumentsDirectory]
  @override
  final String path;
  @override
  final Matrix4 transform;
  @override
  final bool isBlurred;
  @override
  final Color seedColor;
  @override
  final double meanLuminance;
  @override
  final double width;
  @override
  final double height;
  @override
  final double viewportWidth;
  @override
  final double viewportHeight;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BackgroundImage(path: $path, transform: $transform, isBlurred: $isBlurred, seedColor: $seedColor, meanLuminance: $meanLuminance, width: $width, height: $height, viewportWidth: $viewportWidth, viewportHeight: $viewportHeight)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BackgroundImage'))
      ..add(DiagnosticsProperty('path', path))
      ..add(DiagnosticsProperty('transform', transform))
      ..add(DiagnosticsProperty('isBlurred', isBlurred))
      ..add(DiagnosticsProperty('seedColor', seedColor))
      ..add(DiagnosticsProperty('meanLuminance', meanLuminance))
      ..add(DiagnosticsProperty('width', width))
      ..add(DiagnosticsProperty('height', height))
      ..add(DiagnosticsProperty('viewportWidth', viewportWidth))
      ..add(DiagnosticsProperty('viewportHeight', viewportHeight));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BackgroundImageImpl &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.transform, transform) ||
                other.transform == transform) &&
            (identical(other.isBlurred, isBlurred) ||
                other.isBlurred == isBlurred) &&
            (identical(other.seedColor, seedColor) ||
                other.seedColor == seedColor) &&
            (identical(other.meanLuminance, meanLuminance) ||
                other.meanLuminance == meanLuminance) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.viewportWidth, viewportWidth) ||
                other.viewportWidth == viewportWidth) &&
            (identical(other.viewportHeight, viewportHeight) ||
                other.viewportHeight == viewportHeight));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path, transform, isBlurred,
      seedColor, meanLuminance, width, height, viewportWidth, viewportHeight);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BackgroundImageImplCopyWith<_$BackgroundImageImpl> get copyWith =>
      __$$BackgroundImageImplCopyWithImpl<_$BackgroundImageImpl>(
          this, _$identity);
}

abstract class _BackgroundImage extends BackgroundImage {
  const factory _BackgroundImage(
      {required final String path,
      required final Matrix4 transform,
      required final bool isBlurred,
      required final Color seedColor,
      required final double meanLuminance,
      required final double width,
      required final double height,
      required final double viewportWidth,
      required final double viewportHeight}) = _$BackgroundImageImpl;
  const _BackgroundImage._() : super._();

  @override

  /// The path to the image asset relative to the document directory returned by [getApplicationDocumentsDirectory]
  String get path;
  @override
  Matrix4 get transform;
  @override
  bool get isBlurred;
  @override
  Color get seedColor;
  @override
  double get meanLuminance;
  @override
  double get width;
  @override
  double get height;
  @override
  double get viewportWidth;
  @override
  double get viewportHeight;
  @override
  @JsonKey(ignore: true)
  _$$BackgroundImageImplCopyWith<_$BackgroundImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
