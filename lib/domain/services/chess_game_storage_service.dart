import 'package:dartchess/dartchess.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';

import '../collections/chess_game.dart';
import '../collections/player.dart';

class ChessGameStorageService {
  static Isar? db;

  /// âœ… ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
  static Future<void> init() async {
    if (db != null) return;
    final dir = await getApplicationSupportDirectory();

    db = await Isar.open(
      [PlayerSchema, ChessGameSchema], // Schemas generated by build_runner
      directory: dir.path,
      inspector: true,
    );
  }

  Isar get isar {
    if (db == null) {
      throw Exception('Isar database is not initialized. Call init() first.');
    } else {
      return db!;
    }
  }

  /// for tests only: initialize Isar with a provided directory
  static Future<void> initForTest(String directoryPath) async {
    if (db != null) return;
    db = await Isar.open(
      [PlayerSchema, ChessGameSchema],
      directory: directoryPath,
      name: 'test_instance',
      // inspector: false,
    );
  }

  // ğŸ§© Ø­ÙØ¸ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ù„Ø§Ø¹Ø¨
  Future<Player> upsertPlayer(Player player) async {
    await isar.writeTxn(() async {
      await isar.players.put(player);
    });
    return player;
  }

  // ğŸ§© Ø¬Ù„Ø¨ Ù„Ø§Ø¹Ø¨ Ø­Ø³Ø¨ uuid
  Future<Player?> getPlayerByUuid(String uuid) async {
    return await isar.players.filter().uuidEqualTo(uuid).findFirst();
  }

  // ğŸ§© Ø­ÙØ¸ Ù„Ø¹Ø¨Ø© Ù…Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
  Future<ChessGame> saveGame(ChessGame game, Player white, Player black) async {
    await isar.writeTxn(() async {
      await isar.players.putAll([white, black]);
      game.whitePlayer.value = white;
      game.blackPlayer.value = black;
      await isar.chessGames.put(game);
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });
    return game;
  }

  // ğŸ§© Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø¨ØªØ±ØªÙŠØ¨ Ø²Ù…Ù†ÙŠ ØªÙ†Ø§Ø²Ù„ÙŠ
  Future<List<ChessGame>> getAllGames() async {
    final games = await isar.chessGames.where().sortByDateDesc().findAll();
    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // ğŸ§© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø­Ø³Ø¨ Ø§Ù„Ù„Ø§Ø¹Ø¨
  Future<List<ChessGame>> getGamesByPlayer(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];
    final games = await isar.chessGames
        .filter()
        .group(
          (q) => q
              .whitePlayer((w) => w.uuidEqualTo(uuid))
              .or()
              .blackPlayer((b) => b.uuidEqualTo(uuid)),
        )
        .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // ğŸ§© Ø­Ø°Ù Ù„Ø¹Ø¨Ø©
  Future<void> deleteGame(int id) async {
    await isar.writeTxn(() async {
      await isar.chessGames.delete(id);
    });
  }

  // ğŸ§© Ø­Ø°Ù ÙƒÙ„ Ø´ÙŠØ¡ (Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±)
  Future<void> clearAll() async {
    await isar.writeTxn(() async {
      await isar.chessGames.clear();
      await isar.players.clear();
    });
  }

  // ----------------------------
  // Player management (Ø¨Ø¯ÙˆÙ† ØªÙƒØ±Ø§Ø±)
  // ----------------------------
  Future<Player> createPlayer(Player newPlayer) async {
    return upsertPlayer(newPlayer);
  }

  /// Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø§Ø¹Ø¨ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ØŒ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§ØªÙ‡ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯Ù‡ (avoid duplication).
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯.
  Future<Player> createOrGetPlayerByUuid(
    String uuid, {
    String? name,
    int? rating,
    String? type,
  }) async {
    // Ø­Ø§ÙˆÙ„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ
    final existing = await getPlayerByUuid(uuid);
    if (existing != null) {
      // Ø­Ø¯Ø« Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ø¥Ø°Ø§ ØªØºÙŠÙ‘Ø±Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
      bool changed = false;
      if (name != null && existing.name != name) {
        existing.name = name;
        changed = true;
      }
      if (rating != null && existing.playerRating != rating) {
        existing.playerRating = rating;
        changed = true;
      }
      if (type != null && existing.type != type) {
        existing.type = type;
        changed = true;
      }

      if (changed) {
        await isar.writeTxn(() async {
          await isar.players.put(existing);
        });
      }
      return existing;
    } else {
      // ØªØ¹ÙŠÙŠÙ† rating Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ù† Ù„Ù… ÙŠØ¹Ø·Ù
      final effectiveRating = rating ?? 1200;
      final effectiveType = type ?? 'human';
      final player = Player(
        uuid: uuid,
        name: name ?? uuid,
        type: effectiveType,
        playerRating: effectiveRating,
      );

      await isar.writeTxn(() async {
        await isar.players.put(player);
      });
      return player;
    }
  }

  String manualPgnFromSanListForTest(
    PgnHeaders headers,
    List<MoveData> movesData,
    String result,
  ) {
    return _manualPgnFromSanList(headers, movesData, result);
  }
  // ----------------------------
  // Game lifecycle (Ø¨Ø¯Ø¡ØŒ Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ©ØŒ Ù†Ù‡Ø§ÙŠØ©)
  // ----------------------------

  /// Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©: ÙŠÙ†Ø´Ø¦ ÙƒØ§Ø¦Ù† Game ÙˆÙŠØ®Ø²Ù†Ù‡ Ù…Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†.
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù€Game Ø§Ù„Ù…Ø®Ø²Ù‘Ù† (Ù…Ø­ØªÙˆÙŠØ§ØªÙ‡ Ù…Ø¹ id).
  Future<ChessGame> startNewGame({
    required ChessGame chessGame,
    String? startFEN,
    required Player white,
    required Player black,
    required Map<String, String> headers,
    String result = '*',
    String? event,
    String? site,
    String? round,
    DateTime? date,
  }) async {
    final savedWhite = await createOrGetPlayerByUuid(
      white.uuid,
      name: white.name,
      rating: white.playerRating,
      type: white.type,
    );
    final savedBlack = await createOrGetPlayerByUuid(
      black.uuid,
      name: black.name,
      rating: black.playerRating,
      type: black.type,
    );

    // Ø¨Ù†Ø§Ø¡ Ù†Ø³Ø®Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¶Ù…Ø§Ù† ÙˆØ¶ÙˆØ­ Ø§Ù„Ø­Ù‚ÙˆÙ„
    final game = ChessGame()
      ..uuid = chessGame.uuid
      ..event = event ?? chessGame.event
      ..site = site ?? chessGame.site
      ..round = round ?? chessGame.round
      ..date = date ?? chessGame.date ?? DateTime.now()
      ..fullPgn = _manualPgnFromSanList(headers, chessGame.moves, result)
      ..startingFen = startFEN ?? chessGame.startingFen ?? ''
      ..result =
          '*' // Ù„Ù… ØªÙ†ØªÙ‡Ù Ø¨Ø¹Ø¯
      ..movesCount = 0
      ..moves = []
      ..whitePlayer.value = savedWhite
      ..blackPlayer.value = savedBlack;

    await isar.writeTxn(() async {
      await isar.chessGames.put(game);
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });

    return game;
  }

  /// Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ© (SAN) Ù„Ù„Ø¹Ø¨Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆØªØ­Ø¯ÙŠØ« PGN Ùˆ movesCount.
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù€Game Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø¯ÙŠØ«.
  Future<ChessGame> addMoveToGame(int gameId, MoveData moveData) async {
    late ChessGame game;
    await isar.writeTxn(() async {
      final g = await isar.chessGames.get(gameId);
      if (g == null) throw Exception('Game not found: $gameId');

      await g.whitePlayer.load();
      await g.blackPlayer.load();

      g.moves.add(moveData);
      g.movesCount = g.moves.length;

      final headers = <String, String>{
        'Event': g.event ?? 'Casual Game',
        'Site': g.site ?? 'Local',
        'Date': (g.date != null)
            ? g.date!.toIso8601String().split('T').first
            : DateTime.now().toIso8601String().split('T').first,
        'Round': g.round ?? '1',
        'White': g.whitePlayer.value?.name ?? 'White',
        'Black': g.blackPlayer.value?.name ?? 'Black',
        'Result': g.result ?? '*',
      };

      g.fullPgn = _manualPgnFromSanList(headers, g.moves, g.result ?? '*');

      await isar.chessGames.put(g);

      game = g;
    });

    return game;
  }

  /// Ø­ÙØ¸ snapshot Ù…Ø¤Ù‚Øª Ù„Ù„Ø¹Ø¨Ø© (Ù…Ø«Ù„Ø§Ù‹ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø´Ø§Ø´Ø©)
  Future<void> saveGameSnapshot(ChessGame game) async {
    // ignore: unused_local_variable
    final isar = db;
    // await isar.writeTxn(() async {
    //   final g = await isar?.chessGames.get(game.id);
    //   if (g == null) {
    //     // Ù„Ùˆ Ù„Ù… ØªÙƒÙ† Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ø­ÙÙˆØ¸Ø© Ù…Ø³Ø¨Ù‚Ù‹Ø§ØŒ Ù‚Ù… Ø¨ÙˆØ¶Ø¹Ù‡Ø§
    //     await isar!.chessGames.put(game);
    //   } else {
    //     // Ù†Ø­Ø¯Ù‘Ø« Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ù‡Ù…Ø©
    //     g.moves = game.moves;
    //     g.movesUci = game.movesUci;
    //     g.fens = game.fens;
    //     g.pgn = game.pgn;
    //     g.whitesTime = game.whitesTime;
    //     g.blacksTime = game.blacksTime;
    //     g.isGameOver = game.isGameOver;
    //     g.endedAt = game.endedAt;
    //     g.result = game.result;
    //     await isar.games.put(g);
    //   }
    // });
  }

  /// Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©: ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªÙŠØ¬Ø©ØŒ endFENØŒ endTimeØŒ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ PGN Ù…ØªØ¶Ù…Ù†Ù‹Ø§ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©.
  Future<ChessGame> endGame(
    ChessGame chessGame, {
    required String result, // "1-0", "0-1", "1/2-1/2"
    required List<MoveData> movesData,
    String? termination, // Ø³Ø¨Ø¨ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (e.g., "checkmate", "resign", "timeout")
    required PgnHeaders headers,
  }) async {
    await isar.writeTxn(() async {
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
      chessGame.result = result;
      // ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø±Ø¤ÙˆØ³ Ù…Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©

      // Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆÙ„ÙŠØ¯ PGN Ù…Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
      chessGame.fullPgn = _manualPgnFromSanList(
        headers,
        chessGame.moves,
        result,
      );

      await isar.chessGames.put(chessGame);
    });

    return chessGame;
  }

  // ----------------------------
  // Queries (Ø§Ø³ØªØ±Ø¬Ø§Ø¹)
  // ----------------------------

  /// Ø¬Ù„Ø¨ Ù„Ø¹Ø¨Ø© Ù…Ø¹ ØªØ­Ù…ÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
  Future<ChessGame?> getGameWithPlayers(int gameId) async {
    final g = await isar.chessGames.get(gameId);
    if (g == null) return null;
    await g.whitePlayer.load();
    await g.blackPlayer.load();
    return g;
  }

  /// Ø¬Ù„Ø¨ Ø£Ù„Ø¹Ø§Ø¨ Ù„Ø§Ø¹Ø¨ Ø­Ø³Ø¨ uuid (ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ù‚ÙˆÙ„ whitePlayerId / blackPlayerId Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…)
  Future<List<ChessGame>> getGamesByPlayerUuid(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];

    final games = await isar.chessGames
        .filter()
        .group(
          (q) => q
              .whitePlayer((w) => w.idEqualTo(player.id))
              .or()
              .blackPlayer((b) => b.idEqualTo(player.id)),
        )
        .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }
}

String _manualPgnFromSanList(
  Map<String, String>
  headers, // Ø§Ø³ØªØ®Ø¯Ù…Øª Map<String,String> Ù„Ø£Ù† PgnHeaders ØºØ§Ù„Ø¨Ø§Ù‹ Ù‡ÙƒØ°Ø§
  List<MoveData> movesData,
  String result,
) {
  final buffer = StringBuffer();

  final primaryOrder = [
    'Event',
    'Site',
    'Date',
    'Round',
    'White',
    'Black',
    'Result',
  ];

  headers['Result'] = result;

  for (final key in primaryOrder) {
    if (headers.containsKey(key) && (headers[key] ?? '').isNotEmpty) {
      final safeValue = (headers[key] ?? '').replaceAll('"', '\\"');
      buffer.writeln('[$key "$safeValue"]');
    }
  }

  final remainderKeys =
      headers.keys.where((k) => !primaryOrder.contains(k)).toList()..sort();
  for (final key in remainderKeys) {
    final val = headers[key];
    if (val == null) continue;
    final safeValue = val.replaceAll('"', '\\"');
    buffer.writeln('[$key "$safeValue"]');
  }

  buffer.writeln();

  for (int i = 0; i < movesData.length; i++) {
    final md = movesData[i];
    final san = (md.san ?? '').trim();
    if (san.isEmpty) continue;

    if (i % 2 == 0) {
      final moveNumber = (i ~/ 2) + 1;
      buffer.write('$moveNumber. $san');
    } else {
      buffer.write(' $san');
    }

    // NAGs: md.nags is List<int>? -> each stored as $n
    if (md.nags != null && md.nags!.isNotEmpty) {
      for (final n in md.nags!) {
        buffer.write(' \$$n');
      }
    }

    // comment
    if (md.comment != null && md.comment!.trim().isNotEmpty) {
      // basic sanitization: remove '}' and '{' to avoid breaking PGN format
      var safeComment = md.comment!
          .replaceAll('}', '')
          .replaceAll('{', '')
          .trim();
      if (safeComment.isNotEmpty) {
        buffer.write(' {$safeComment}');
      }
    }

    // variations: each variation expected as a raw string or san sequence
    if (md.variations != null && md.variations!.isNotEmpty) {
      for (final rawVar in md.variations!) {
        final varText = rawVar.trim();
        if (varText.isEmpty) continue;
        if (varText.startsWith('(') && varText.endsWith(')')) {
          buffer.write(' $varText');
        } else {
          buffer.write(' ($varText)');
        }
      }
    }

    if (i != movesData.length - 1) buffer.write(' ');
  }

  buffer.write(' $result');

  return buffer.toString();
}

/// ÙŠØ¨Ù†ÙŠ Ù†Øµ PGN Ø¨Ø³ÙŠØ· Ù…Ù† Ø±Ø¤ÙˆØ³ PGN Ùˆ Ù‚Ø§Ø¦Ù…Ø© MoveData (ÙŠØ¯Ø¹Ù… SAN, NAG, comment, variations).
// String _manualPgnFromSanList(
//   PgnHeaders headers, // PgnHeaders Ù…Ù† Ø­Ø²Ù…Ø© dartchess (Ø®Ø±ÙŠØ·Ø© Ø±Ø¤ÙˆØ³)
//   List<MoveData> movesData, // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø¨ØµÙŠØºØ© MoveData (ÙƒÙ…Ø§ Ø¹Ø±Ù‘ÙØªÙ‡Ø§)
//   String result, // Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© "1-0" / "0-1" / "1/2-1/2" / "*"
// ) {
//   final buffer = StringBuffer();

//   // 1) ØªØ±ØªÙŠØ¨ Ø§Ù„Ø±Ø¤ÙˆØ³ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø·Ø¨Ø§Ø¹ØªÙ‡Ø§ Ø£ÙˆÙ„Ø§Ù‹ (ØªØ±ØªÙŠØ¨ Ø´Ø§Ø¦Ø¹ Ù„Ù„Ù€PGN)
//   final primaryOrder = [
//     'Event',
//     'Site',
//     'Date',
//     'Round',
//     'White',
//     'Black',
//     'Result',
//   ];

//   // Ù†ØªØ£ÙƒØ¯ Ø£Ù† header 'Result' ÙŠØ¹ÙƒØ³ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…Ù…Ø±Ø±Ø©
//   headers['Result'] = result;

//   // Ø£ÙƒØªØ¨ Ø§Ù„Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¨Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø¥Ù† ÙˆÙØ¬Ø¯Øª
//   for (final key in primaryOrder) {
//     if (headers.containsKey(key) &&
//         headers[key] != null &&
//         headers[key]!.isNotEmpty) {
//       final safeValue = headers[key]!.replaceAll(
//         '"',
//         '\\"',
//       ); // Ø§Ù‡Ø±ÙˆØ¨ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø§Ù‚ØªØ¨Ø§Ø³
//       buffer.writeln('[$key "$safeValue"]');
//     }
//   }

//   // Ø£ÙƒØªØ¨ Ø£ÙŠ Ø±Ø¤ÙˆØ³ Ø¥Ø¶Ø§ÙÙŠØ© ØºÙŠØ± Ø§Ù„Ù…Ø¯Ø±Ø¬Ø© ÙÙŠ primaryOrder
//   final remainderKeys =
//       headers.keys.where((k) => !primaryOrder.contains(k)).toList()..sort();
//   for (final key in remainderKeys) {
//     final val = headers[key];
//     if (val == null) continue;
//     final safeValue = val.replaceAll('"', '\\"');
//     buffer.writeln('[$key "$safeValue"]');
//   }

//   // Ø³Ø·Ø± ÙØ§Ø±Øº ÙŠÙØµÙ„ Ø§Ù„Ø±Ø¤ÙˆØ³ Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª
//   buffer.writeln();

//   // 2) ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª Ù…Ø¹ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
//   for (int i = 0; i < movesData.length; i++) {
//     final MoveData md = movesData[i];

//     // SAN Ù…Ø·Ù„ÙˆØ¨ Ù€ Ø¥Ù† Ù„Ù… ÙŠÙˆØ¬Ø¯ Ù†ØªØ®Ø·Ù‰ Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ­Ø¯Ø©
//     final san = (md.san ?? '').trim();
//     if (san.isEmpty) {
//       // Ù†ØªØ®Ø·Ù‰ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ÙØ§Ø±ØºØ© - ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ù„ÙˆÙƒ Ù„Ø±Ù…ÙŠ Ø§Ø³ØªØ«Ù†Ø§Ø¡
//       continue;
//     }

//     // Ù„Ùˆ ÙƒØ§Ù†Øª Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø¨ÙŠØ¶ (even index) Ù†ÙƒØªØ¨ Ø±Ù‚Ù… Ø§Ù„Ø­Ø±ÙƒØ© Ù‚Ø¨Ù„Ù‡Ø§
//     if (i % 2 == 0) {
//       final moveNumber = (i ~/ 2) + 1;
//       buffer.write('$moveNumber. $san');
//     } else {
//       // Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø³ÙˆØ¯ (Ù„Ø§ Ù†ÙƒØ±Ø± Ø±Ù‚Ù… Ø§Ù„Ø­Ø±ÙƒØ©)
//       buffer.write(' $san');
//     }

//     // 2.a) NAG (Numeric Annotation Glyph)
//     //TODO fix list nags to add to pgn
//     if (md.nags != null && md.nags!.join('').trim().isNotEmpty) {
//       String nagText = md.nags!.join('').trim();
//       //TODO fix list nags to add to pgn
//       // String nagText = md.nag!.trim();
//       // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø±Ù‚Ù…Ù‹Ø§ ÙÙ‚Ø·ØŒ Ø­ÙˆÙ‘Ù„Ù‡ Ù„ØµÙŠØºØ© $n
//       if (!nagText.startsWith('\$')) {
//         final maybeNum = int.tryParse(nagText);
//         if (maybeNum != null) {
//           nagText = '\$$maybeNum';
//         }
//       }
//       buffer.write(' $nagText');
//     }

//     // 2.b) ØªØ¹Ù„ÙŠÙ‚ (comment) ÙŠÙˆØ¶Ø¹ Ø¨ÙŠÙ† { }
//     if (md.comment != null && md.comment!.trim().isNotEmpty) {
//       // Ù†Ø²ÙŠÙ„ Ø£Ùˆ Ù†Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© (Ù„Ø§ ØªÙØ³Ù…Ø­ '}' Ø¯Ø§Ø®Ù„ ØªØ¹Ù„ÙŠÙ‚ PGN Ø¹Ø§Ø¯Ø©)
//       var safeComment = md.comment!.replaceAll('}', ''); // Ø£Ø¨Ø³Ø· Ù…Ø¹Ø§Ù„Ø¬Ø©
//       safeComment = safeComment.trim();
//       buffer.write(' {$safeComment}');
//     }

//     // 2.c) Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª (variations) â€” Ù†ØªÙˆÙ‚Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ù†ØµÙˆØµ ØµØºÙŠØ±Ø© Ù„ØªÙ…Ø«ÙŠÙ„ ÙƒÙ„ Ù…ØªØºÙŠØ±
//     if (md.variations != null && md.variations!.isNotEmpty) {
//       for (final rawVar in md.variations!) {
//         final varText = rawVar.trim();
//         if (varText.isEmpty) continue;
//         // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ ÙŠØ¨Ø¯Ø£ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‚ÙˆØ³ÙŠÙ† Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙƒÙ…Ø§ Ù‡ÙˆØŒ ÙˆØ¥Ù„Ø§ Ø£ØºÙ„ÙÙ‡ Ø¨Ù‚ÙˆØ³ÙŠÙ†
//         if (varText.startsWith('(') && varText.endsWith(')')) {
//           buffer.write(' $varText');
//         } else {
//           buffer.write(' ($varText)');
//         }
//       }
//     }

//     // Ø£Ø¶Ù Ù…Ø³Ø§ÙØ© ÙØ§ØµÙ„Ø© Ø¨ÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ§Øª (Ù…Ø§ Ø¹Ø¯Ø§ Ø¨Ø¹Ø¯ Ø¢Ø®Ø± Ø­Ø±ÙƒØ© Ø³Ù†Ø¶ÙŠÙ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹)
//     if (i != movesData.length - 1) buffer.write(' ');
//   }

//   // 3) Ø£Ø¶Ù Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (Ù…Ø¹ Ù…Ø³Ø§ÙØ© ÙØ§ØµÙ„Ø©)
//   buffer.write(' $result');

//   return buffer.toString();
// }
