import 'package:dartchess/dartchess.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';

import '../collections/chess_game.dart';
import '../collections/player.dart';

class ChessGameStorageService {
  // static final ChessGameStorageService _instance =
  //     ChessGameStorageService._internal();

  // factory ChessGameStorageService() => _instance;
  // ChessGameStorageService._internal();

  // static late Isar db;
  static Isar? db;

  /// âœ… ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
  static Future<void> init() async {
    if (db != null) return;
    final dir = await getApplicationSupportDirectory();

    db = await Isar.open(
      [PlayerSchema, ChessGameSchema], // Schemas generated by build_runner
      directory: dir.path,
      inspector: true,
    );
  }

  Isar get isar {
    if (db == null) {
      throw Exception('Isar database is not initialized. Call init() first.');
    } else {
      return db!;
    }
  }

  // ğŸ§© Ø­ÙØ¸ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ù„Ø§Ø¹Ø¨
  Future<Player> upsertPlayer(Player player) async {
    await isar.writeTxn(() async {
      await isar.players.put(player);
    });
    return player;
  }

  // ğŸ§© Ø¬Ù„Ø¨ Ù„Ø§Ø¹Ø¨ Ø­Ø³Ø¨ uuid
  Future<Player?> getPlayerByUuid(String uuid) async {
    return await isar.players.filter().uuidEqualTo(uuid).findFirst();
  }

  // ğŸ§© Ø­ÙØ¸ Ù„Ø¹Ø¨Ø© Ù…Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
  Future<ChessGame> saveGame(ChessGame game, Player white, Player black) async {
    await isar.writeTxn(() async {
      await isar.players.putAll([white, black]);
      game.whitePlayer.value = white;
      game.blackPlayer.value = black;
      await isar.chessGames.put(game);
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });
    return game;
  }

  // ğŸ§© Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø¨ØªØ±ØªÙŠØ¨ Ø²Ù…Ù†ÙŠ ØªÙ†Ø§Ø²Ù„ÙŠ
  Future<List<ChessGame>> getAllGames() async {
    final games = await isar.chessGames.where().sortByDateDesc().findAll();
    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // ğŸ§© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø­Ø³Ø¨ Ø§Ù„Ù„Ø§Ø¹Ø¨
  Future<List<ChessGame>> getGamesByPlayer(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];
    final games =
        await isar.chessGames
            .filter()
            .group(
              (q) => q
                  .whitePlayer((w) => w.uuidEqualTo(uuid))
                  .or()
                  .blackPlayer((b) => b.uuidEqualTo(uuid)),
            )
            .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // ğŸ§© Ø­Ø°Ù Ù„Ø¹Ø¨Ø©
  Future<void> deleteGame(int id) async {
    await isar.writeTxn(() async {
      await isar.chessGames.delete(id);
    });
  }

  // ğŸ§© Ø­Ø°Ù ÙƒÙ„ Ø´ÙŠØ¡ (Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±)
  Future<void> clearAll() async {
    await isar.writeTxn(() async {
      await isar.chessGames.clear();
      await isar.players.clear();
    });
  }

  /// ÙŠØ¨Ù†ÙŠ Ù†Øµ PGN Ø¨Ø³ÙŠØ· Ù…Ù† Ø±Ø¤ÙˆØ³ PGN Ùˆ Ù‚Ø§Ø¦Ù…Ø© MoveData (ÙŠØ¯Ø¹Ù… SAN, NAG, comment, variations).
  String _manualPgnFromSanList(
    PgnHeaders headers, // PgnHeaders Ù…Ù† Ø­Ø²Ù…Ø© dartchess (Ø®Ø±ÙŠØ·Ø© Ø±Ø¤ÙˆØ³)
    List<MoveData> movesData, // Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø¨ØµÙŠØºØ© MoveData (ÙƒÙ…Ø§ Ø¹Ø±Ù‘ÙØªÙ‡Ø§)
    String result, // Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© "1-0" / "0-1" / "1/2-1/2" / "*"
  ) {
    final buffer = StringBuffer();

    // 1) ØªØ±ØªÙŠØ¨ Ø§Ù„Ø±Ø¤ÙˆØ³ Ø§Ù„Ù…Ø±Ø§Ø¯ Ø·Ø¨Ø§Ø¹ØªÙ‡Ø§ Ø£ÙˆÙ„Ø§Ù‹ (ØªØ±ØªÙŠØ¨ Ø´Ø§Ø¦Ø¹ Ù„Ù„Ù€PGN)
    final primaryOrder = [
      'Event',
      'Site',
      'Date',
      'Round',
      'White',
      'Black',
      'Result',
    ];

    // Ù†ØªØ£ÙƒØ¯ Ø£Ù† header 'Result' ÙŠØ¹ÙƒØ³ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù…Ù…Ø±Ø±Ø©
    headers['Result'] = result;

    // Ø£ÙƒØªØ¨ Ø§Ù„Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¨Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ© Ø¥Ù† ÙˆÙØ¬Ø¯Øª
    for (final key in primaryOrder) {
      if (headers.containsKey(key) &&
          headers[key] != null &&
          headers[key]!.isNotEmpty) {
        final safeValue = headers[key]!.replaceAll(
          '"',
          '\\"',
        ); // Ø§Ù‡Ø±ÙˆØ¨ Ø¹Ù„Ø§Ù…Ø§Øª Ø§Ù„Ø§Ù‚ØªØ¨Ø§Ø³
        buffer.writeln('[$key "$safeValue"]');
      }
    }

    // Ø£ÙƒØªØ¨ Ø£ÙŠ Ø±Ø¤ÙˆØ³ Ø¥Ø¶Ø§ÙÙŠØ© ØºÙŠØ± Ø§Ù„Ù…Ø¯Ø±Ø¬Ø© ÙÙŠ primaryOrder
    final remainderKeys =
        headers.keys.where((k) => !primaryOrder.contains(k)).toList()..sort();
    for (final key in remainderKeys) {
      final val = headers[key];
      if (val == null) continue;
      final safeValue = val.replaceAll('"', '\\"');
      buffer.writeln('[$key "$safeValue"]');
    }

    // Ø³Ø·Ø± ÙØ§Ø±Øº ÙŠÙØµÙ„ Ø§Ù„Ø±Ø¤ÙˆØ³ Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª
    buffer.writeln();

    // 2) ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª Ù…Ø¹ Ø§Ù„ØªØ±Ù…ÙŠØ² Ø§Ù„Ù…Ù†Ø§Ø³Ø¨
    for (int i = 0; i < movesData.length; i++) {
      final MoveData md = movesData[i];

      // SAN Ù…Ø·Ù„ÙˆØ¨ Ù€ Ø¥Ù† Ù„Ù… ÙŠÙˆØ¬Ø¯ Ù†ØªØ®Ø·Ù‰ Ù‡Ø°Ù‡ Ø§Ù„ÙˆØ­Ø¯Ø©
      final san = (md.san ?? '').trim();
      if (san.isEmpty) {
        // Ù†ØªØ®Ø·Ù‰ Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ÙØ§Ø±ØºØ© - ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø§Ù„Ø³Ù„ÙˆÙƒ Ù„Ø±Ù…ÙŠ Ø§Ø³ØªØ«Ù†Ø§Ø¡
        continue;
      }

      // Ù„Ùˆ ÙƒØ§Ù†Øª Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø¨ÙŠØ¶ (even index) Ù†ÙƒØªØ¨ Ø±Ù‚Ù… Ø§Ù„Ø­Ø±ÙƒØ© Ù‚Ø¨Ù„Ù‡Ø§
      if (i % 2 == 0) {
        final moveNumber = (i ~/ 2) + 1;
        buffer.write('$moveNumber. $san');
      } else {
        // Ø­Ø±ÙƒØ© Ø§Ù„Ø£Ø³ÙˆØ¯ (Ù„Ø§ Ù†ÙƒØ±Ø± Ø±Ù‚Ù… Ø§Ù„Ø­Ø±ÙƒØ©)
        buffer.write(' $san');
      }

      // 2.a) NAG (Numeric Annotation Glyph)
      //TODO fix list nags to add to pgn
      // if (md.nag != null && md.nag!.trim().isNotEmpty) {
      if (md.nags != null && md.nags!.join('').isNotEmpty) {
        String nagText = md.nags!.join('').trim();
        //TODO fix list nags to add to pgn
        // String nagText = md.nag!.trim();
        // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø±Ù‚Ù…Ù‹Ø§ ÙÙ‚Ø·ØŒ Ø­ÙˆÙ‘Ù„Ù‡ Ù„ØµÙŠØºØ© $n
        if (!nagText.startsWith('\$')) {
          final maybeNum = int.tryParse(nagText);
          if (maybeNum != null) {
            nagText = '\$$maybeNum';
          }
        }
        buffer.write(' $nagText');
      }

      // 2.b) ØªØ¹Ù„ÙŠÙ‚ (comment) ÙŠÙˆØ¶Ø¹ Ø¨ÙŠÙ† { }
      if (md.comment != null && md.comment!.trim().isNotEmpty) {
        // Ù†Ø²ÙŠÙ„ Ø£Ùˆ Ù†Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© (Ù„Ø§ ØªÙØ³Ù…Ø­ '}' Ø¯Ø§Ø®Ù„ ØªØ¹Ù„ÙŠÙ‚ PGN Ø¹Ø§Ø¯Ø©)
        var safeComment = md.comment!.replaceAll('}', ''); // Ø£Ø¨Ø³Ø· Ù…Ø¹Ø§Ù„Ø¬Ø©
        safeComment = safeComment.trim();
        buffer.write(' {$safeComment}');
      }

      // 2.c) Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª (variations) â€” Ù†ØªÙˆÙ‚Ø¹ Ù‚Ø§Ø¦Ù…Ø© Ù†ØµÙˆØµ ØµØºÙŠØ±Ø© Ù„ØªÙ…Ø«ÙŠÙ„ ÙƒÙ„ Ù…ØªØºÙŠØ±
      if (md.variations != null && md.variations!.isNotEmpty) {
        for (final rawVar in md.variations!) {
          final varText = rawVar.trim();
          if (varText.isEmpty) continue;
          // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù†Øµ ÙŠØ¨Ø¯Ø£ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¨Ù‚ÙˆØ³ÙŠÙ† Ø§Ø³ØªØ®Ø¯Ù…Ù‡ ÙƒÙ…Ø§ Ù‡ÙˆØŒ ÙˆØ¥Ù„Ø§ Ø£ØºÙ„ÙÙ‡ Ø¨Ù‚ÙˆØ³ÙŠÙ†
          if (varText.startsWith('(') && varText.endsWith(')')) {
            buffer.write(' $varText');
          } else {
            buffer.write(' ($varText)');
          }
        }
      }

      // Ø£Ø¶Ù Ù…Ø³Ø§ÙØ© ÙØ§ØµÙ„Ø© Ø¨ÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ§Øª (Ù…Ø§ Ø¹Ø¯Ø§ Ø¨Ø¹Ø¯ Ø¢Ø®Ø± Ø­Ø±ÙƒØ© Ø³Ù†Ø¶ÙŠÙ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹)
      if (i != movesData.length - 1) buffer.write(' ');
    }

    // 3) Ø£Ø¶Ù Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ© ÙÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (Ù…Ø¹ Ù…Ø³Ø§ÙØ© ÙØ§ØµÙ„Ø©)
    buffer.write(' $result');

    return buffer.toString();
  }

  /// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙˆÙ„ÙŠØ¯ PGN Ø¨Ø³ÙŠØ· Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© SAN Ùˆ headers
  /// Ù…Ø®ØµØµØ© Ù„Ù„Ù€ mainline ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† ØªØ¹Ù‚ÙŠØ¯Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª/variations)
  // String _manualPgnFromSanList(
  //   Map<String, String> headers,
  //   List<String> sanMoves,
  //   String result,
  // ) {
  //   final buffer = StringBuffer();

  //   // Ø±Ø¤ÙˆØ³ PGN
  //   headers.forEach((k, v) {
  //     buffer.writeln('[$k "${v.replaceAll('"', '\\"')}"]');
  //   });
  //   buffer.writeln();

  //   // ØªØ±Ù‚ÙŠÙ… Ø§Ù„Ø­Ø±ÙƒØ§Øª
  //   for (int i = 0; i < sanMoves.length; i += 2) {
  //     final moveNumber = (i ~/ 2) + 1;
  //     buffer.write('$moveNumber. ${sanMoves[i]}');
  //     if (i + 1 < sanMoves.length) buffer.write(' ${sanMoves[i + 1]}');
  //     if (i + 2 < sanMoves.length) buffer.write(' ');
  //   }

  //   buffer.write(' $result');
  //   return buffer.toString();
  // }

  // ----------------------------
  // Player management (Ø¨Ø¯ÙˆÙ† ØªÙƒØ±Ø§Ø±)
  // ----------------------------
  Future<Player> createPlayer(Player newPlayer) async {
    return upsertPlayer(newPlayer);
  }

  /// Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø§Ø¹Ø¨ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ØŒ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§ØªÙ‡ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯Ù‡ (avoid duplication).
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯.
  Future<Player> createOrGetPlayerByUuid(
    String uuid, {
    String? name,
    int? rating,
    String? type,
  }) async {
    // Ø­Ø§ÙˆÙ„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ
    final existing = await getPlayerByUuid(uuid);
    if (existing != null) {
      // Ø­Ø¯Ø« Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ø¥Ø°Ø§ ØªØºÙŠÙ‘Ø±Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
      bool changed = false;
      if (name != null && existing.name != name) {
        existing.name = name;
        changed = true;
      }
      if (rating != null && existing.playerRating != rating) {
        existing.playerRating = rating;
        changed = true;
      }

      if (changed) {
        await isar.writeTxn(() async {
          await isar.players.put(existing);
        });
      }
      return existing;
    } else {
      // Ø£Ù†Ø´Ø¦ Ù„Ø§Ø¹Ø¨Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§ ÙˆØ®Ø²Ù†
      final player =
          Player(uuid: uuid, name: name ?? uuid, type: type ?? '')
            ..playerRating = rating!
            ..createdAt = DateTime.now();

      await isar.writeTxn(() async {
        await isar.players.put(player);
      });
      return player;
    }
  }

  // ----------------------------
  // Game lifecycle (Ø¨Ø¯Ø¡ØŒ Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ©ØŒ Ù†Ù‡Ø§ÙŠØ©)
  // ----------------------------

  /// Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©: ÙŠÙ†Ø´Ø¦ ÙƒØ§Ø¦Ù† Game ÙˆÙŠØ®Ø²Ù†Ù‡ Ù…Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†.
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù€Game Ø§Ù„Ù…Ø®Ø²Ù‘Ù† (Ù…Ø­ØªÙˆÙŠØ§ØªÙ‡ Ù…Ø¹ id).
  Future<ChessGame> startNewGame({
    required ChessGame chessGame,
    String? startFEN,
    required Player white,
    required Player black,
    required PgnHeaders headers,
    String result = '*',
    String? event,
    String? site,
    String? round,
    DateTime? date,
  }) async {
    // ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† ÙˆØ¹Ø¯Ù… ØªÙƒØ±Ø§Ø±Ù‡Ù…
    final savedWhite = await createOrGetPlayerByUuid(
      white.uuid,
      name: white.name,
      rating: white.playerRating,
    );
    final savedBlack = await createOrGetPlayerByUuid(
      black.uuid,
      name: black.name,
      rating: black.playerRating,
    );

    final game =
        chessGame
          ..fullPgn = _manualPgnFromSanList(headers, chessGame.moves, result)
          // Ø³Ù†Ù…Ù„Ø£Ù‡ ØªØ¯Ø±ÙŠØ¬ÙŠÙ‹Ø§
          ..movesCount = 0
          ..moves = []
          ..event = event
          ..site = site
          ..round = round
          ..date = date ?? DateTime.now()
          ..result =
              '*' // Ù„Ù… ØªÙ†ØªÙ‡Ù Ø¨Ø¹Ø¯
          // ..status = 'ongoing'
          ..startingFen =
              startFEN ??
              '' // Ø¶Ø¹ FEN Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø£Ùˆ ÙØ±Ø§Øº
          ..date = DateTime.now()
          ..whitePlayer.value = savedWhite
          ..blackPlayer.value = savedBlack
          ..whitePlayer.value = savedWhite
          ..blackPlayer.value = savedBlack;

    await isar.writeTxn(() async {
      await isar.chessGames.put(game);
      // Ø­ÙØ¸ Ø±ÙˆØ§Ø¨Ø· IsarLink
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });

    return game;
  }

  /// Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ© (SAN) Ù„Ù„Ø¹Ø¨Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆØªØ­Ø¯ÙŠØ« PGN Ùˆ movesCount.
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù€Game Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø¯ÙŠØ«.
  Future<ChessGame> addMoveToGame(int gameId, MoveData moveData) async {
    late ChessGame game;
    await isar.writeTxn(() async {
      final g = await isar.chessGames.get(gameId);
      if (g == null) throw Exception('Game not found: $gameId');

      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù„Ù‚Ø±Ø§Ø¡Ø© Ø£Ø³Ù…Ø§Ø¦Ù‡Ù… (Ù…Ø·Ù„ÙˆØ¨ Ù„Ø¨Ù†Ø§Ø¡ Ø±Ø¤ÙˆØ³ PGN)
      await g.whitePlayer.load();
      await g.blackPlayer.load();

      // Ø£Ø¶Ù Ø§Ù„Ø­Ø±ÙƒØ©
      g.moves.add(moveData);
      g.movesCount = g.moves.length;

      // Ø¨Ù†Ø§Ø¡ Ø±Ø¤ÙˆØ³ PGN Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ ÙÙŠ Ø§Ù„Ù†Øµ
      final headers = <String, String>{
        'Event': g.event ?? 'Casual Game',
        'Site': g.site ?? 'Local',
        'Date':
            (g.date != null)
                ? g.date!.toIso8601String().split('T').first
                : DateTime.now().toIso8601String().split('T').first,
        'Round': g.round ?? '1',
        'White': g.whitePlayer.value?.name ?? 'White',
        'Black': g.blackPlayer.value?.name ?? 'Black',
        'Result': g.result ?? '*',
      };

      // Ø£Ø¹ÙØ¯ ØªÙˆÙ„ÙŠØ¯ PGN Ø§Ø¹ØªÙ…Ø§Ø¯Ù‹Ø§ Ø¹Ù„Ù‰ moves Ø§Ù„Ø­Ø§Ù„ÙŠØ©
      g.fullPgn = _manualPgnFromSanList(headers, game.moves, g.result ?? '*');

      // Ø®Ø²Ù‘Ù† Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
      await isar.chessGames.put(g);

      game = g;
    });

    return game;
  }

  /// Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©: ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªÙŠØ¬Ø©ØŒ endFENØŒ endTimeØŒ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ PGN Ù…ØªØ¶Ù…Ù†Ù‹Ø§ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©.
  Future<ChessGame> endGame(
    ChessGame chessGame, {
    required String result, // "1-0", "0-1", "1/2-1/2"
    required List<MoveData> movesData,
    String? termination, // Ø³Ø¨Ø¨ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (e.g., "checkmate", "resign", "timeout")
    required PgnHeaders headers,
  }) async {
    await isar.writeTxn(() async {
      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
      chessGame.result = result;
      // ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø±Ø¤ÙˆØ³ Ù…Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©

      // Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆÙ„ÙŠØ¯ PGN Ù…Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
      chessGame.fullPgn = _manualPgnFromSanList(
        headers,
        chessGame.moves,
        result,
      );

      await isar.chessGames.put(chessGame);
    });

    return chessGame;
  }

  // ----------------------------
  // Queries (Ø§Ø³ØªØ±Ø¬Ø§Ø¹)
  // ----------------------------

  /// Ø¬Ù„Ø¨ Ù„Ø¹Ø¨Ø© Ù…Ø¹ ØªØ­Ù…ÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
  Future<ChessGame?> getGameWithPlayers(int gameId) async {
    final g = await isar.chessGames.get(gameId);
    if (g == null) return null;
    await g.whitePlayer.load();
    await g.blackPlayer.load();
    return g;
  }

  /// Ø¬Ù„Ø¨ Ø£Ù„Ø¹Ø§Ø¨ Ù„Ø§Ø¹Ø¨ Ø­Ø³Ø¨ uuid (ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ù‚ÙˆÙ„ whitePlayerId / blackPlayerId Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…)
  Future<List<ChessGame>> getGamesByPlayerUuid(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];

    final games =
        await isar.chessGames
            .filter()
            .group(
              (q) => q
                  .whitePlayer((w) => w.idEqualTo(player.id))
                  .or()
                  .blackPlayer((b) => b.idEqualTo(player.id)),
            )
            .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }
}
