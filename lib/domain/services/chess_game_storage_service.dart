import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';

import '../models/chess_game.dart';
import '../models/player.dart';

class ChessGameStorageService {
  // static final ChessGameStorageService _instance =
  //     ChessGameStorageService._internal();

  // factory ChessGameStorageService() => _instance;
  // ChessGameStorageService._internal();

  // static late Isar db;
  static Isar? db;

  /// âœ… ÙØªØ­ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·
  static Future<void> init() async {
    if (db != null) return;
    final dir = await getApplicationSupportDirectory();

    db = await Isar.open(
      [PlayerSchema, ChessGameSchema], // Schemas generated by build_runner
      directory: dir.path,
      inspector: true,
    );
  }

  Isar get isar {
    if (db == null) {
      throw Exception('Isar database is not initialized. Call init() first.');
    } else {
      return db!;
    }
  }

  // ğŸ§© Ø­ÙØ¸ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ù„Ø§Ø¹Ø¨
  Future<Player> upsertPlayer(Player player) async {
    await isar.writeTxn(() async {
      await isar.players.put(player);
    });
    return player;
  }

  // ğŸ§© Ø¬Ù„Ø¨ Ù„Ø§Ø¹Ø¨ Ø­Ø³Ø¨ uuid
  Future<Player?> getPlayerByUuid(String uuid) async {
    return await isar.players.filter().uuidEqualTo(uuid).findFirst();
  }

  // ğŸ§© Ø­ÙØ¸ Ù„Ø¹Ø¨Ø© Ù…Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
  Future<ChessGame> saveGame(ChessGame game, Player white, Player black) async {
    await isar.writeTxn(() async {
      await isar.players.putAll([white, black]);
      game.whitePlayer.value = white;
      game.blackPlayer.value = black;
      await isar.chessGames.put(game);
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });
    return game;
  }

  // ğŸ§© Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø¨ØªØ±ØªÙŠØ¨ Ø²Ù…Ù†ÙŠ ØªÙ†Ø§Ø²Ù„ÙŠ
  Future<List<ChessGame>> getAllGames() async {
    final games = await isar.chessGames.where().sortByDateDesc().findAll();
    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // ğŸ§© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£Ù„Ø¹Ø§Ø¨ Ø­Ø³Ø¨ Ø§Ù„Ù„Ø§Ø¹Ø¨
  Future<List<ChessGame>> getGamesByPlayer(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];
    final games =
        await isar.chessGames
            .filter()
            .group(
              (q) => q
                  .whitePlayer((w) => w.uuidEqualTo(uuid))
                  .or()
                  .blackPlayer((b) => b.uuidEqualTo(uuid)),
            )
            .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // ğŸ§© Ø­Ø°Ù Ù„Ø¹Ø¨Ø©
  Future<void> deleteGame(int id) async {
    await isar.writeTxn(() async {
      await isar.chessGames.delete(id);
    });
  }

  // ğŸ§© Ø­Ø°Ù ÙƒÙ„ Ø´ÙŠØ¡ (Ù„Ù„Ø§Ø®ØªØ¨Ø§Ø±)
  Future<void> clearAll() async {
    await isar.writeTxn(() async {
      await isar.chessGames.clear();
      await isar.players.clear();
    });
  }

  /// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªÙˆÙ„ÙŠØ¯ PGN Ø¨Ø³ÙŠØ· Ù…Ù† Ù‚Ø§Ø¦Ù…Ø© SAN Ùˆ headers
  /// Ù…Ø®ØµØµØ© Ù„Ù„Ù€ mainline ÙÙ‚Ø· (Ø¨Ø¯ÙˆÙ† ØªØ¹Ù‚ÙŠØ¯Ø§Øª Ø§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª/variations)
  String _manualPgnFromSanList(
    Map<String, String> headers,
    List<String> sanMoves,
    String result,
  ) {
    final buffer = StringBuffer();

    // Ø±Ø¤ÙˆØ³ PGN
    headers.forEach((k, v) {
      buffer.writeln('[$k "${v.replaceAll('"', '\\"')}"]');
    });
    buffer.writeln();

    // ØªØ±Ù‚ÙŠÙ… Ø§Ù„Ø­Ø±ÙƒØ§Øª
    for (int i = 0; i < sanMoves.length; i += 2) {
      final moveNumber = (i ~/ 2) + 1;
      buffer.write('$moveNumber. ${sanMoves[i]}');
      if (i + 1 < sanMoves.length) buffer.write(' ${sanMoves[i + 1]}');
      if (i + 2 < sanMoves.length) buffer.write(' ');
    }

    buffer.write(' $result');
    return buffer.toString();
  }

  // ----------------------------
  // Player management (Ø¨Ø¯ÙˆÙ† ØªÙƒØ±Ø§Ø±)
  // ----------------------------

  /// Ø¥Ù†Ø´Ø§Ø¡ Ù„Ø§Ø¹Ø¨ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯ØŒ Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ø¨ÙŠØ§Ù†Ø§ØªÙ‡ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯Ù‡ (avoid duplication).
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„ÙƒØ§Ø¦Ù† Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯ Ø£Ùˆ Ø§Ù„Ø¬Ø¯ÙŠØ¯.
  Future<Player> createOrGetPlayerByUuid(
    String uuid, {
    String? name,
    int? rating,
    String? type,
  }) async {
    // Ø­Ø§ÙˆÙ„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ø­Ø§Ù„ÙŠ
    final existing = await getPlayerByUuid(uuid);
    if (existing != null) {
      // Ø­Ø¯Ø« Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¨Ø³ÙŠØ·Ø© Ø¥Ø°Ø§ ØªØºÙŠÙ‘Ø±Øª (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
      bool changed = false;
      if (name != null && existing.name != name) {
        existing.name = name;
        changed = true;
      }
      if (rating != null && existing.playerRating != rating) {
        existing.playerRating = rating;
        changed = true;
      }

      if (changed) {
        await isar.writeTxn(() async {
          await isar.players.put(existing);
        });
      }
      return existing;
    } else {
      // Ø£Ù†Ø´Ø¦ Ù„Ø§Ø¹Ø¨Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§ ÙˆØ®Ø²Ù†
      final player =
          Player(uuid: uuid, name: name ?? uuid, type: type ?? '')
            ..playerRating = rating!
            ..createdAt = DateTime.now();

      await isar.writeTxn(() async {
        await isar.players.put(player);
      });
      return player;
    }
  }

  // ----------------------------
  // Game lifecycle (Ø¨Ø¯Ø¡ØŒ Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ©ØŒ Ù†Ù‡Ø§ÙŠØ©)
  // ----------------------------

  /// Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©: ÙŠÙ†Ø´Ø¦ ÙƒØ§Ø¦Ù† Game ÙˆÙŠØ®Ø²Ù†Ù‡ Ù…Ø¹ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†.
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù€Game Ø§Ù„Ù…Ø®Ø²Ù‘Ù† (Ù…Ø­ØªÙˆÙŠØ§ØªÙ‡ Ù…Ø¹ id).
  Future<ChessGame> startNewGame({
    String? startFEN,
    required Player white,
    required Player black,
    String? event,
    String? site,
    String? round,
    DateTime? date,
  }) async {
    // ØªØ£ÙƒØ¯ Ù…Ù† Ø­ÙØ¸ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† ÙˆØ¹Ø¯Ù… ØªÙƒØ±Ø§Ø±Ù‡Ù…
    final savedWhite = await createOrGetPlayerByUuid(
      white.uuid,
      name: white.name,
      rating: white.playerRating,
    );
    final savedBlack = await createOrGetPlayerByUuid(
      black.uuid,
      name: black.name,
      rating: black.playerRating,
    );

    final game =
        ChessGame()
          ..fullPgn =
              '' // Ø³Ù†Ù…Ù„Ø£Ù‡ ØªØ¯Ø±ÙŠØ¬ÙŠÙ‹Ø§
          ..movesCount = 0
          ..moves = []
          ..event = event
          ..site = site
          ..round = round
          ..date = date ?? DateTime.now()
          ..result =
              '*' // Ù„Ù… ØªÙ†ØªÙ‡Ù Ø¨Ø¹Ø¯
          // ..status = 'ongoing'
          ..startingFen =
              startFEN ??
              '' // Ø¶Ø¹ FEN Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ø£Ùˆ ÙØ±Ø§Øº
          ..date = DateTime.now()
          ..whitePlayer.value = savedWhite
          ..blackPlayer.value = savedBlack
          ..whitePlayer.value = savedWhite
          ..blackPlayer.value = savedBlack;

    await isar.writeTxn(() async {
      await isar.chessGames.put(game);
      // Ø­ÙØ¸ Ø±ÙˆØ§Ø¨Ø· IsarLink
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });

    return game;
  }

  /// Ø¥Ø¶Ø§ÙØ© Ø­Ø±ÙƒØ© (SAN) Ù„Ù„Ø¹Ø¨Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© ÙˆØªØ­Ø¯ÙŠØ« PGN Ùˆ movesCount.
  /// ÙŠØ¹ÙŠØ¯ Ø§Ù„Ù€Game Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ø¯ÙŠØ«.
  Future<ChessGame> addMoveToGame(int gameId, MoveData moveData) async {
    late ChessGame game;
    await isar.writeTxn(() async {
      final g = await isar.chessGames.get(gameId);
      if (g == null) throw Exception('Game not found: $gameId');

      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù„Ù‚Ø±Ø§Ø¡Ø© Ø£Ø³Ù…Ø§Ø¦Ù‡Ù… (Ù…Ø·Ù„ÙˆØ¨ Ù„Ø¨Ù†Ø§Ø¡ Ø±Ø¤ÙˆØ³ PGN)
      await g.whitePlayer.load();
      await g.blackPlayer.load();

      // Ø£Ø¶Ù Ø§Ù„Ø­Ø±ÙƒØ©
      g.moves.add(moveData);
      g.movesCount = g.moves.length;

      // Ø¨Ù†Ø§Ø¡ Ø±Ø¤ÙˆØ³ PGN Ø§Ù„Ø­Ø§Ù„ÙŠØ© Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡Ø§ ÙÙŠ Ø§Ù„Ù†Øµ
      final headers = <String, String>{
        'Event': g.event ?? 'Casual Game',
        'Site': g.site ?? 'Local',
        'Date':
            (g.date != null)
                ? g.date!.toIso8601String().split('T').first
                : DateTime.now().toIso8601String().split('T').first,
        'Round': g.round ?? '1',
        'White': g.whitePlayer.value?.name ?? 'White',
        'Black': g.blackPlayer.value?.name ?? 'Black',
        'Result': g.result ?? '*',
      };
      final sanMoves = g.moves.map((s) => s.san!).toList();

      // Ø£Ø¹ÙØ¯ ØªÙˆÙ„ÙŠØ¯ PGN Ø§Ø¹ØªÙ…Ø§Ø¯Ù‹Ø§ Ø¹Ù„Ù‰ moves Ø§Ù„Ø­Ø§Ù„ÙŠØ©
      g.fullPgn = _manualPgnFromSanList(headers, sanMoves, g.result ?? '*');

      // Ø®Ø²Ù‘Ù† Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª
      await isar.chessGames.put(g);

      game = g;
    });

    return game;
  }

  /// Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©: ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªÙŠØ¬Ø©ØŒ endFENØŒ endTimeØŒ Ø§Ù„Ø­Ø§Ù„Ø©ØŒ ÙˆØ¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ PGN Ù…ØªØ¶Ù…Ù†Ù‹Ø§ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©.
  Future<ChessGame> endGame(
    int gameId, {
    required String result, // "1-0", "0-1", "1/2-1/2"
    String? endFEN,
    String? termination, // Ø³Ø¨Ø¨ Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (e.g., "checkmate", "resign", "timeout")
  }) async {
    late ChessGame game;
    await isar.writeTxn(() async {
      final g = await isar.chessGames.get(gameId);
      if (g == null) throw Exception('Game not found: $gameId');

      // ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø³Ù…Ø§Ø¦Ù‡Ù… (Ù„Ø±Ø¤ÙˆØ³ PGN)
      await g.whitePlayer.load();
      await g.blackPlayer.load();

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
      g.result = result;
      // g.endFEN = endFEN;
      // g.endTime = DateTime.now();
      // g.status = 'finished';

      // ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø±Ø¤ÙˆØ³ Ù…Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
      final headers = <String, String>{
        'Event': g.event ?? 'Casual Game',
        'Site': g.site ?? 'Local',
        'Date':
            (g.date != null)
                ? g.date!.toIso8601String().split('T').first
                : DateTime.now().toIso8601String().split('T').first,
        'Round': g.round ?? '1',
        'White': g.whitePlayer.value?.name ?? 'White',
        'Black': g.blackPlayer.value?.name ?? 'Black',
        'Result': g.result ?? result,
      };
      final sanMoves = g.moves.map((s) => s.san!).toList();
      // Ø¥Ø¹Ø§Ø¯Ø© ØªÙˆÙ„ÙŠØ¯ PGN Ù…Ø¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
      g.fullPgn = _manualPgnFromSanList(headers, sanMoves, g.result ?? result);

      await isar.chessGames.put(g);
      game = g;
    });

    return game;
  }

  // ----------------------------
  // Queries (Ø§Ø³ØªØ±Ø¬Ø§Ø¹)
  // ----------------------------

  /// Ø¬Ù„Ø¨ Ù„Ø¹Ø¨Ø© Ù…Ø¹ ØªØ­Ù…ÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†
  Future<ChessGame?> getGameWithPlayers(int gameId) async {
    final g = await isar.chessGames.get(gameId);
    if (g == null) return null;
    await g.whitePlayer.load();
    await g.blackPlayer.load();
    return g;
  }

  /// Ø¬Ù„Ø¨ Ø£Ù„Ø¹Ø§Ø¨ Ù„Ø§Ø¹Ø¨ Ø­Ø³Ø¨ uuid (ÙŠØ³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ù‚ÙˆÙ„ whitePlayerId / blackPlayerId Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø§Ø³ØªØ¹Ù„Ø§Ù…)
  Future<List<ChessGame>> getGamesByPlayerUuid(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];

    final games =
        await isar.chessGames
            .filter()
            .group(
              (q) => q
                  .whitePlayer((w) => w.idEqualTo(player.id))
                  .or()
                  .blackPlayer((b) => b.idEqualTo(player.id)),
            )
            .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }
}
