import 'package:dartchess/dartchess.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';

import '../collections/chess_game.dart';
import '../collections/player.dart';

class ChessGameStorageService {
  // static final ChessGameStorageService _instance =
  //     ChessGameStorageService._internal();

  // factory ChessGameStorageService() => _instance;
  // ChessGameStorageService._internal();

  // static late Isar db;
  static Isar? db;

  /// ✅ فتح قاعدة البيانات لمرة واحدة فقط
  static Future<void> init() async {
    if (db != null) return;
    final dir = await getApplicationSupportDirectory();

    db = await Isar.open(
      [PlayerSchema, ChessGameSchema], // Schemas generated by build_runner
      directory: dir.path,
      inspector: true,
    );
  }

  Isar get isar {
    if (db == null) {
      throw Exception('Isar database is not initialized. Call init() first.');
    } else {
      return db!;
    }
  }

  // 🧩 حفظ أو تحديث لاعب
  Future<Player> upsertPlayer(Player player) async {
    await isar.writeTxn(() async {
      await isar.players.put(player);
    });
    return player;
  }

  // 🧩 جلب لاعب حسب uuid
  Future<Player?> getPlayerByUuid(String uuid) async {
    return await isar.players.filter().uuidEqualTo(uuid).findFirst();
  }

  // 🧩 حفظ لعبة مع روابط اللاعبين
  Future<ChessGame> saveGame(ChessGame game, Player white, Player black) async {
    await isar.writeTxn(() async {
      await isar.players.putAll([white, black]);
      game.whitePlayer.value = white;
      game.blackPlayer.value = black;
      await isar.chessGames.put(game);
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });
    return game;
  }

  // 🧩 جلب جميع الألعاب بترتيب زمني تنازلي
  Future<List<ChessGame>> getAllGames() async {
    final games = await isar.chessGames.where().sortByDateDesc().findAll();
    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // 🧩 البحث عن الألعاب حسب اللاعب
  Future<List<ChessGame>> getGamesByPlayer(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];
    final games =
        await isar.chessGames
            .filter()
            .group(
              (q) => q
                  .whitePlayer((w) => w.uuidEqualTo(uuid))
                  .or()
                  .blackPlayer((b) => b.uuidEqualTo(uuid)),
            )
            .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }

  // 🧩 حذف لعبة
  Future<void> deleteGame(int id) async {
    await isar.writeTxn(() async {
      await isar.chessGames.delete(id);
    });
  }

  // 🧩 حذف كل شيء (للاختبار)
  Future<void> clearAll() async {
    await isar.writeTxn(() async {
      await isar.chessGames.clear();
      await isar.players.clear();
    });
  }

  /// يبني نص PGN بسيط من رؤوس PGN و قائمة MoveData (يدعم SAN, NAG, comment, variations).
  String _manualPgnFromSanList(
    PgnHeaders headers, // PgnHeaders من حزمة dartchess (خريطة رؤوس)
    List<MoveData> movesData, // قائمة الحركات بصيغة MoveData (كما عرّفتها)
    String result, // نتيجة اللعبة "1-0" / "0-1" / "1/2-1/2" / "*"
  ) {
    final buffer = StringBuffer();

    // 1) ترتيب الرؤوس المراد طباعتها أولاً (ترتيب شائع للـPGN)
    final primaryOrder = [
      'Event',
      'Site',
      'Date',
      'Round',
      'White',
      'Black',
      'Result',
    ];

    // نتأكد أن header 'Result' يعكس النتيجة الممررة
    headers['Result'] = result;

    // أكتب الرؤوس الأساسية بالأولوية إن وُجدت
    for (final key in primaryOrder) {
      if (headers.containsKey(key) &&
          headers[key] != null &&
          headers[key]!.isNotEmpty) {
        final safeValue = headers[key]!.replaceAll(
          '"',
          '\\"',
        ); // اهروب علامات الاقتباس
        buffer.writeln('[$key "$safeValue"]');
      }
    }

    // أكتب أي رؤوس إضافية غير المدرجة في primaryOrder
    final remainderKeys =
        headers.keys.where((k) => !primaryOrder.contains(k)).toList()..sort();
    for (final key in remainderKeys) {
      final val = headers[key];
      if (val == null) continue;
      final safeValue = val.replaceAll('"', '\\"');
      buffer.writeln('[$key "$safeValue"]');
    }

    // سطر فارغ يفصل الرؤوس عن الحركات
    buffer.writeln();

    // 2) كتابة الحركات مع الترميز المناسب
    for (int i = 0; i < movesData.length; i++) {
      final MoveData md = movesData[i];

      // SAN مطلوب ـ إن لم يوجد نتخطى هذه الوحدة
      final san = (md.san ?? '').trim();
      if (san.isEmpty) {
        // نتخطى الحركات الفارغة - يمكنك تغيير السلوك لرمي استثناء
        continue;
      }

      // لو كانت حركة الأبيض (even index) نكتب رقم الحركة قبلها
      if (i % 2 == 0) {
        final moveNumber = (i ~/ 2) + 1;
        buffer.write('$moveNumber. $san');
      } else {
        // حركة الأسود (لا نكرر رقم الحركة)
        buffer.write(' $san');
      }

      // 2.a) NAG (Numeric Annotation Glyph)
      //TODO fix list nags to add to pgn
      // if (md.nag != null && md.nag!.trim().isNotEmpty) {
      if (md.nags != null && md.nags!.join('').isNotEmpty) {
        String nagText = md.nags!.join('').trim();
        //TODO fix list nags to add to pgn
        // String nagText = md.nag!.trim();
        // إذا كان رقمًا فقط، حوّله لصيغة $n
        if (!nagText.startsWith('\$')) {
          final maybeNum = int.tryParse(nagText);
          if (maybeNum != null) {
            nagText = '\$$maybeNum';
          }
        }
        buffer.write(' $nagText');
      }

      // 2.b) تعليق (comment) يوضع بين { }
      if (md.comment != null && md.comment!.trim().isNotEmpty) {
        // نزيل أو نحل المشكلات الصغيرة (لا تُسمح '}' داخل تعليق PGN عادة)
        var safeComment = md.comment!.replaceAll('}', ''); // أبسط معالجة
        safeComment = safeComment.trim();
        buffer.write(' {$safeComment}');
      }

      // 2.c) المتغيرات (variations) — نتوقع قائمة نصوص صغيرة لتمثيل كل متغير
      if (md.variations != null && md.variations!.isNotEmpty) {
        for (final rawVar in md.variations!) {
          final varText = rawVar.trim();
          if (varText.isEmpty) continue;
          // إذا كان النص يبدأ بالفعل بقوسين استخدمه كما هو، وإلا أغلفه بقوسين
          if (varText.startsWith('(') && varText.endsWith(')')) {
            buffer.write(' $varText');
          } else {
            buffer.write(' ($varText)');
          }
        }
      }

      // أضف مسافة فاصلة بين الحركات (ما عدا بعد آخر حركة سنضيف النتيجة لاحقاً)
      if (i != movesData.length - 1) buffer.write(' ');
    }

    // 3) أضف النتيجة النهائية في النهاية (مع مسافة فاصلة)
    buffer.write(' $result');

    return buffer.toString();
  }

  /// دالة مساعدة لتوليد PGN بسيط من قائمة SAN و headers
  /// مخصصة للـ mainline فقط (بدون تعقيدات التعليقات/variations)
  // String _manualPgnFromSanList(
  //   Map<String, String> headers,
  //   List<String> sanMoves,
  //   String result,
  // ) {
  //   final buffer = StringBuffer();

  //   // رؤوس PGN
  //   headers.forEach((k, v) {
  //     buffer.writeln('[$k "${v.replaceAll('"', '\\"')}"]');
  //   });
  //   buffer.writeln();

  //   // ترقيم الحركات
  //   for (int i = 0; i < sanMoves.length; i += 2) {
  //     final moveNumber = (i ~/ 2) + 1;
  //     buffer.write('$moveNumber. ${sanMoves[i]}');
  //     if (i + 1 < sanMoves.length) buffer.write(' ${sanMoves[i + 1]}');
  //     if (i + 2 < sanMoves.length) buffer.write(' ');
  //   }

  //   buffer.write(' $result');
  //   return buffer.toString();
  // }

  // ----------------------------
  // Player management (بدون تكرار)
  // ----------------------------
  Future<Player> createPlayer(Player newPlayer) async {
    return upsertPlayer(newPlayer);
  }

  /// إنشاء لاعب إذا لم يوجد، أو تحديث بياناته في حال وجوده (avoid duplication).
  /// يعيد الكائن الموجود أو الجديد.
  Future<Player> createOrGetPlayerByUuid(
    String uuid, {
    String? name,
    int? rating,
    String? type,
  }) async {
    // حاول الحصول على اللاعب الحالي
    final existing = await getPlayerByUuid(uuid);
    if (existing != null) {
      // حدث الحقول البسيطة إذا تغيّرت (اختياري)
      bool changed = false;
      if (name != null && existing.name != name) {
        existing.name = name;
        changed = true;
      }
      if (rating != null && existing.playerRating != rating) {
        existing.playerRating = rating;
        changed = true;
      }

      if (changed) {
        await isar.writeTxn(() async {
          await isar.players.put(existing);
        });
      }
      return existing;
    } else {
      // أنشئ لاعبًا جديدًا وخزن
      final player =
          Player(uuid: uuid, name: name ?? uuid, type: type ?? '')
            ..playerRating = rating!
            ..createdAt = DateTime.now();

      await isar.writeTxn(() async {
        await isar.players.put(player);
      });
      return player;
    }
  }

  // ----------------------------
  // Game lifecycle (بدء، إضافة حركة، نهاية)
  // ----------------------------

  /// بدء لعبة جديدة: ينشئ كائن Game ويخزنه مع روابط اللاعبين.
  /// يعيد الـGame المخزّن (محتوياته مع id).
  Future<ChessGame> startNewGame({
    required ChessGame chessGame,
    String? startFEN,
    required Player white,
    required Player black,
    required PgnHeaders headers,
    String result = '*',
    String? event,
    String? site,
    String? round,
    DateTime? date,
  }) async {
    // تأكد من حفظ اللاعبين وعدم تكرارهم
    final savedWhite = await createOrGetPlayerByUuid(
      white.uuid,
      name: white.name,
      rating: white.playerRating,
    );
    final savedBlack = await createOrGetPlayerByUuid(
      black.uuid,
      name: black.name,
      rating: black.playerRating,
    );

    final game =
        chessGame
          ..fullPgn = _manualPgnFromSanList(headers, chessGame.moves, result)
          // سنملأه تدريجيًا
          ..movesCount = 0
          ..moves = []
          ..event = event
          ..site = site
          ..round = round
          ..date = date ?? DateTime.now()
          ..result =
              '*' // لم تنتهِ بعد
          // ..status = 'ongoing'
          ..startingFen =
              startFEN ??
              '' // ضع FEN البداية أو فراغ
          ..date = DateTime.now()
          ..whitePlayer.value = savedWhite
          ..blackPlayer.value = savedBlack
          ..whitePlayer.value = savedWhite
          ..blackPlayer.value = savedBlack;

    await isar.writeTxn(() async {
      await isar.chessGames.put(game);
      // حفظ روابط IsarLink
      await game.whitePlayer.save();
      await game.blackPlayer.save();
    });

    return game;
  }

  /// إضافة حركة (SAN) للعبة موجودة وتحديث PGN و movesCount.
  /// يعيد الـGame بعد التحديث.
  Future<ChessGame> addMoveToGame(int gameId, MoveData moveData) async {
    late ChessGame game;
    await isar.writeTxn(() async {
      final g = await isar.chessGames.get(gameId);
      if (g == null) throw Exception('Game not found: $gameId');

      // تحميل اللاعبين لقراءة أسمائهم (مطلوب لبناء رؤوس PGN)
      await g.whitePlayer.load();
      await g.blackPlayer.load();

      // أضف الحركة
      g.moves.add(moveData);
      g.movesCount = g.moves.length;

      // بناء رؤوس PGN الحالية لاستخدامها في النص
      final headers = <String, String>{
        'Event': g.event ?? 'Casual Game',
        'Site': g.site ?? 'Local',
        'Date':
            (g.date != null)
                ? g.date!.toIso8601String().split('T').first
                : DateTime.now().toIso8601String().split('T').first,
        'Round': g.round ?? '1',
        'White': g.whitePlayer.value?.name ?? 'White',
        'Black': g.blackPlayer.value?.name ?? 'Black',
        'Result': g.result ?? '*',
      };

      // أعِد توليد PGN اعتمادًا على moves الحالية
      g.fullPgn = _manualPgnFromSanList(headers, game.moves, g.result ?? '*');

      // خزّن التغييرات
      await isar.chessGames.put(g);

      game = g;
    });

    return game;
  }

  /// إنهاء اللعبة: تحديث النتيجة، endFEN، endTime، الحالة، وإعادة بناء PGN متضمنًا النتيجة النهائية.
  Future<ChessGame> endGame(
    ChessGame chessGame, {
    required String result, // "1-0", "0-1", "1/2-1/2"
    required List<MoveData> movesData,
    String? termination, // سبب النهاية (e.g., "checkmate", "resign", "timeout")
    required PgnHeaders headers,
  }) async {
    await isar.writeTxn(() async {
      // تحديث الحالة
      chessGame.result = result;
      // تحضير الرؤوس مع النتيجة النهائية

      // إعادة توليد PGN مع النتيجة النهائية
      chessGame.fullPgn = _manualPgnFromSanList(
        headers,
        chessGame.moves,
        result,
      );

      await isar.chessGames.put(chessGame);
    });

    return chessGame;
  }

  // ----------------------------
  // Queries (استرجاع)
  // ----------------------------

  /// جلب لعبة مع تحميل روابط اللاعبين
  Future<ChessGame?> getGameWithPlayers(int gameId) async {
    final g = await isar.chessGames.get(gameId);
    if (g == null) return null;
    await g.whitePlayer.load();
    await g.blackPlayer.load();
    return g;
  }

  /// جلب ألعاب لاعب حسب uuid (يستخدم الحقول whitePlayerId / blackPlayerId لسرعة الاستعلام)
  Future<List<ChessGame>> getGamesByPlayerUuid(String uuid) async {
    final player = await getPlayerByUuid(uuid);
    if (player == null) return [];

    final games =
        await isar.chessGames
            .filter()
            .group(
              (q) => q
                  .whitePlayer((w) => w.idEqualTo(player.id))
                  .or()
                  .blackPlayer((b) => b.idEqualTo(player.id)),
            )
            .findAll();

    for (final g in games) {
      await g.whitePlayer.load();
      await g.blackPlayer.load();
    }
    return games;
  }
}
