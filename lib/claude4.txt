Ø¨Ø¹Ø¯ ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ø§Ù„Ù…Ù„ØµÙ‚Ø©ØŒ Ø³Ø£Ù‚ÙˆÙ… Ø¨ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:
ğŸ” ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:
1. ÙÙŠ GameController Ø§Ù„Ø­Ø§Ù„ÙŠ:
âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªÙƒØ§Ù…Ù„ ØµØ­ÙŠØ­ Ù…Ø¹ chessground package
âŒ Ø¯Ø§Ù„Ø© makeMove ØªØ³ØªØ®Ø¯Ù… UCI ÙÙ‚Ø· Ø¨ÙŠÙ†Ù…Ø§ chessground ÙŠØ±Ø³Ù„ NormalMove Ù…Ø¨Ø§Ø´Ø±Ø©
âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¯Ø¹Ù… Ù„Ù„Ù€ premove Ùˆ promotion
âŒ validMoves Ù„ÙŠØ³Øª Ø¨Ø§Ù„ØµÙŠØºØ© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù„Ù€ chessground (IMap)
âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ lastMove Ù„Ù„Ø¥Ø¶Ø§Ø¡Ø©
âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµØ­ÙŠØ­Ø© Ù„Ù€ promotion dialog
2. ÙÙŠ GameScreen:
âŒ Ø¹Ø¯Ù… Ø§Ø³ØªØ®Ø¯Ø§Ù… chessground Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù„Ù„Ù€ ValidMoves Ø¨ØµÙŠØºØ© IMap
âŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ GameData ÙƒØ§Ù…Ù„
âœ… Ø§Ù„Ø­Ù„: Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 1: ØªØ­Ø¯ÙŠØ« GameController
// lib/presentation/controllers/game_controller.dart (UPDATED)

import 'package:chessground/chessground.dart' as cg;
import 'package:dartchess/dartchess.dart';
import 'package:fast_immutable_collections/fast_immutable_collections.dart';
import 'package:get/get.dart';
import 'package:uuid/uuid.dart';
import '../../core/game_termination_enum.dart';
import '../../core/utils/game_state.dart';
import '../../core/utils/logger.dart';
import '../../domain/converters/game_state_converter.dart';
import '../../domain/entities/chess_game_entity.dart';
import '../../domain/entities/player_entity.dart';
import '../../domain/services/game_service.dart';
import '../../domain/usecases/game/save_game_usecase.dart';
import '../../domain/usecases/game/update_game_usecase.dart';
import '../../domain/usecases/game/get_game_by_uuid_usecase.dart';
import '../../domain/usecases/game_state/cache_game_state_usecase.dart';
import '../../domain/usecases/game_state/get_cached_game_state_usecase.dart';
import '../../domain/usecases/player/save_player_usecase.dart';
import '../../domain/usecases/player/get_or_create_guest_player_usecase.dart';

/// Main game controller managing game state and business logic
/// Ø§Ù„Ù…ØªØ­ÙƒÙ… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆÙ…Ù†Ø·Ù‚ Ø§Ù„Ø£Ø¹Ù…Ø§Ù„
class GameController extends GetxController {
  // ========== Dependencies (Use Cases) ==========
  final SaveGameUseCase _saveGameUseCase;
  final UpdateGameUseCase _updateGameUseCase;
  final GetGameByUuidUseCase _getGameByUuidUseCase;
  final CacheGameStateUseCase _cacheGameStateUseCase;
  final GetCachedGameStateUseCase _getCachedGameStateUseCase;
  final SavePlayerUseCase _savePlayerUseCase;
  final GetOrCreateGuestPlayerUseCase _getOrCreateGuestPlayerUseCase;

  GameController({
    required SaveGameUseCase saveGameUseCase,
    required UpdateGameUseCase updateGameUseCase,
    required GetGameByUuidUseCase getGameByUuidUseCase,
    required CacheGameStateUseCase cacheGameStateUseCase,
    required GetCachedGameStateUseCase getCachedGameStateUseCase,
    required SavePlayerUseCase savePlayerUseCase,
    required GetOrCreateGuestPlayerUseCase getOrCreateGuestPlayerUseCase,
  })  : _saveGameUseCase = saveGameUseCase,
        _updateGameUseCase = updateGameUseCase,
        _getGameByUuidUseCase = getGameByUuidUseCase,
        _cacheGameStateUseCase = cacheGameStateUseCase,
        _getCachedGameStateUseCase = getCachedGameStateUseCase,
        _savePlayerUseCase = savePlayerUseCase,
        _getOrCreateGuestPlayerUseCase = getOrCreateGuestPlayerUseCase;

  // ========== Observable State ==========
  
  /// Current game state
  late GameState _gameState;
  GameState get gameState => _gameState;

  /// Current chess game entity
  final Rx<ChessGameEntity?> _currentGame = Rx<ChessGameEntity?>(null);
  ChessGameEntity? get currentGame => _currentGame.value;

  /// Loading state
  final RxBool _isLoading = false.obs;
  bool get isLoading => _isLoading.value;

  /// Error message
  final RxString _errorMessage = ''.obs;
  String get errorMessage => _errorMessage.value;

  /// Current position FEN (reactive)
  final RxString _currentFen = Chess.initial.fen.obs;
  String get currentFen => _currentFen.value;

  /// Current turn (reactive)
  final Rx<Side> _currentTurn = Side.white.obs;
  Side get currentTurn => _currentTurn.value;

  /// Is game over (reactive)
  final RxBool _isGameOver = false.obs;
  bool get isGameOver => _isGameOver.value;

  /// Game result (reactive)
  final RxString _gameResult = '*'.obs;
  String get gameResult => _gameResult.value;

  /// Game termination reason (reactive)
  final Rx<GameTermination> _termination = GameTermination.ongoing.obs;
  GameTermination get termination => _termination.value;

  /// Last move (reactive) - for chessground highlighting
  final Rx<cg.Move?> _lastMove = Rx<cg.Move?>(null);
  cg.Move? get lastMove => _lastMove.value;

  /// Valid moves for chessground (IMap format)
  final Rx<cg.ValidMoves> _validMoves = cg.ValidMoves({}).obs;
  cg.ValidMoves get validMoves => _validMoves.value;

  /// Promotion move (waiting for promotion selection)
  final Rx<NormalMove?> _promotionMove = Rx<NormalMove?>(null);
  NormalMove? get promotionMove => _promotionMove.value;

  /// Premove
  final Rx<NormalMove?> _premove = Rx<NormalMove?>(null);
  NormalMove? get premove => _premove.value;

  /// Can undo (reactive)
  final RxBool _canUndo = false.obs;
  bool get canUndo => _canUndo.value;

  /// Can redo (reactive)
  final RxBool _canRedo = false.obs;
  bool get canRedo => _canRedo.value;

  /// Material advantage for white (reactive)
  final RxInt _materialAdvantage = 0.obs;
  int get materialAdvantage => _materialAdvantage.value;

  /// Is position in check (reactive)
  final RxBool _isCheck = false.obs;
  bool get isCheck => _isCheck.value;

  /// Auto-save enabled
  final RxBool _autoSaveEnabled = true.obs;
  bool get autoSaveEnabled => _autoSaveEnabled.value;
  set autoSaveEnabled(bool value) => _autoSaveEnabled.value = value;

  /// Board orientation
  final Rx<Side> _orientation = Side.white.obs;
  Side get orientation => _orientation.value;
  set orientation(Side value) => _orientation.value = value;

  // ========== Lifecycle Methods ==========

  @override
  void onInit() {
    super.onInit();
    AppLogger.info('GameController initialized', tag: 'GameController');
  }

  @override
  void onClose() {
    AppLogger.info('GameController disposed', tag: 'GameController');
    _gameState.dispose();
    super.onClose();
  }

  // ========== Public Methods ==========

  /// Initialize a new game
  Future<void> startNewGame({
    required String whitePlayerName,
    required String blackPlayerName,
    String? event,
    String? site,
    String? timeControl,
  }) async {
    try {
      _setLoading(true);
      _clearError();

      AppLogger.gameEvent('StartNewGame', data: {
        'white': whitePlayerName,
        'black': blackPlayerName,
      });

      // Create or get players
      final whitePlayerResult = await _getOrCreateGuestPlayerUseCase(
        GetOrCreateGuestPlayerParams(name: whitePlayerName),
      );

      final blackPlayerResult = await _getOrCreateGuestPlayerUseCase(
        GetOrCreateGuestPlayerParams(name: blackPlayerName),
      );

      if (whitePlayerResult.isLeft() || blackPlayerResult.isLeft()) {
        _setError('Failed to create players');
        return;
      }

      final whitePlayer = whitePlayerResult.getOrElse(() => throw Exception());
      final blackPlayer = blackPlayerResult.getOrElse(() => throw Exception());

      // Generate UUID for new game
      final gameUuid = const Uuid().v4();

      // Initialize GameState
      _gameState = GameState(initial: Chess.initial);

      // Create ChessGameEntity
      final newGame = ChessGameEntity(
        uuid: gameUuid,
        event: event ?? 'Casual Game',
        site: site ?? 'Local',
        date: DateTime.now(),
        round: '1',
        whitePlayer: whitePlayer,
        blackPlayer: blackPlayer,
        result: '*',
        termination: GameTermination.ongoing,
        timeControl: timeControl,
        startingFen: Chess.initial.fen,
        moves: const [],
        movesCount: 0,
      );

      // Save game to database
      final saveResult = await _saveGameUseCase(
        SaveGameParams(game: newGame),
      );

      saveResult.fold(
        (failure) {
          _setError('Failed to save game: ${failure.message}');
          AppLogger.error('Failed to save game', tag: 'GameController');
        },
        (savedGame) async {
          _currentGame.value = savedGame;

          // Cache game state
          final stateEntity = GameStateConverter.toEntity(_gameState, gameUuid);
          await _cacheGameStateUseCase(
            CacheGameStateParams(state: stateEntity),
          );

          _updateReactiveState();

          AppLogger.gameEvent('NewGameStarted', data: {'uuid': gameUuid});
          Get.snackbar(
            'Game Started',
            'New game between $whitePlayerName vs $blackPlayerName',
            snackPosition: SnackPosition.BOTTOM,
          );
        },
      );
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error starting new game',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Unexpected error: ${e.toString()}');
    } finally {
      _setLoading(false);
    }
  }

  /// Load existing game by UUID
  Future<void> loadGame(String gameUuid) async {
    try {
      _setLoading(true);
      _clearError();

      AppLogger.gameEvent('LoadGame', data: {'uuid': gameUuid});

      // Try to get from cache first
      final cachedResult = await _getCachedGameStateUseCase(
        GetCachedGameStateParams(gameUuid: gameUuid),
      );

      if (cachedResult.isRight()) {
        final cachedState = cachedResult.getOrElse(() => throw Exception());
        _gameState = GameStateConverter.fromEntity(cachedState);

        // Also load the game entity from database
        final gameResult = await _getGameByUuidUseCase(
          GetGameByUuidParams(uuid: gameUuid),
        );

        gameResult.fold(
          (failure) => _setError('Failed to load game: ${failure.message}'),
          (game) {
            _currentGame.value = game;
            _updateReactiveState();
            AppLogger.gameEvent('GameLoadedFromCache', data: {'uuid': gameUuid});
          },
        );
        return;
      }

      // Load from database
      final gameResult = await _getGameByUuidUseCase(
        GetGameByUuidParams(uuid: gameUuid),
      );

      gameResult.fold(
        (failure) => _setError('Failed to load game: ${failure.message}'),
        (game) {
          _currentGame.value = game;

          // Restore GameState from entity
          final restoreResult = GameService.restoreGameStateFromEntity(game);
          restoreResult.fold(
            (failure) => _setError('Failed to restore game state: ${failure.message}'),
            (restoredState) {
              _gameState = restoredState;
              _updateReactiveState();

              // Cache the state
              final stateEntity = GameStateConverter.toEntity(_gameState, gameUuid);
              _cacheGameStateUseCase(CacheGameStateParams(state: stateEntity));

              AppLogger.gameEvent('GameLoaded', data: {'uuid': gameUuid});
              Get.snackbar(
                'Game Loaded',
                'Loaded game: ${game.event ?? 'Untitled'}',
                snackPosition: SnackPosition.BOTTOM,
              );
            },
          );
        },
      );
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error loading game',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Unexpected error: ${e.toString()}');
    } finally {
      _setLoading(false);
    }
  }

  /// Handle move from chessground (NormalMove object)
  /// This is the main method called by chessground
  Future<void> onUserMove(NormalMove move, {bool? isDrop, bool? isPremove}) async {
    try {
      if (_isGameOver.value) {
        Get.snackbar(
          'Game Over',
          'Cannot make moves in a finished game',
          snackPosition: SnackPosition.BOTTOM,
        );
        return;
      }

      // Check if this is a promotion pawn move
      if (_isPromotionPawnMove(move)) {
        _promotionMove.value = move;
        update();
        return;
      }

      // Validate and execute move
      if (_gameState.position.isLegal(move)) {
        await _executeMove(move);
      } else {
        Get.snackbar(
          'Invalid Move',
          'This move is not legal',
          snackPosition: SnackPosition.BOTTOM,
        );
      }
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error handling user move',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Failed to make move: ${e.toString()}');
    }
  }

  /// Handle promotion selection
  void onPromotionSelection(Role? role) {
    if (role == null) {
      // Cancel promotion
      _promotionMove.value = null;
      update();
      return;
    }

    if (_promotionMove.value != null) {
      final moveWithPromotion = _promotionMove.value!.withPromotion(role);
      _promotionMove.value = null;
      _executeMove(moveWithPromotion);
    }
  }

  /// Set premove
  void onSetPremove(NormalMove? move) {
    _premove.value = move;
    update();
  }

  /// Execute move and update state
  Future<void> _executeMove(NormalMove move) async {
    try {
      // Play the move
      _gameState.play(move, nags: []);

      // Update reactive state
      _updateReactiveState();

      // Auto-save if enabled
      if (_autoSaveEnabled.value) {
        await _autoSaveGame();
      }

      // Play sound based on move type
      final meta = _gameState.lastMoveMeta;
      if (meta != null) {
        // Here you would call your sound use case
        // plySound.executeMoveSound() or similar
      }

      AppLogger.move(
        meta?.san ?? move.uci,
        fen: _currentFen.value,
        isCheck: _isCheck.value,
      );

      // Try to execute premove if any
      _tryPlayPremove();
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error executing move',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Failed to execute move: ${e.toString()}');
    }
  }

  /// Try to play premove
  void _tryPlayPremove() {
    if (_premove.value != null) {
      final premove = _premove.value!;
      _premove.value = null;
      onUserMove(premove, isPremove: true);
    }
  }

  /// Check if move is a promotion pawn move
  bool _isPromotionPawnMove(NormalMove move) {
    return move.promotion == null &&
        _gameState.position.board.roleAt(move.from) == Role.pawn &&
        ((move.to.rank == 0 && _gameState.position.turn == Side.black) ||
            (move.to.rank == 7 && _gameState.position.turn == Side.white));
  }

  /// Undo last move
  Future<void> undoMove() async {
    try {
      if (!_gameState.canUndo) {
        Get.snackbar(
          'Cannot Undo',
          'No moves to undo',
          snackPosition: SnackPosition.BOTTOM,
        );
        return;
      }

      final success = _gameState.undoMove();

      if (success) {
        _updateReactiveState();

        // Auto-save if enabled
        if (_autoSaveEnabled.value) {
          await _autoSaveGame();
        }

        AppLogger.gameEvent('MoveUndone');
      }
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error undoing move',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Failed to undo move: ${e.toString()}');
    }
  }

  /// Redo previously undone move
  Future<void> redoMove() async {
    try {
      if (!_gameState.canRedo) {
        Get.snackbar(
          'Cannot Redo',
          'No moves to redo',
          snackPosition: SnackPosition.BOTTOM,
        );
        return;
      }

      final success = _gameState.redoMove();

      if (success) {
        _updateReactiveState();

        // Auto-save if enabled
        if (_autoSaveEnabled.value) {
          await _autoSaveGame();
        }

        AppLogger.gameEvent('MoveRedone');
      }
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error redoing move',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Failed to redo move: ${e.toString()}');
    }
  }

  /// Resign the game
  Future<void> resign(Side side) async {
    try {
      _gameState.resign(side);
      _updateReactiveState();

      await _saveGameToDatabase();

      AppLogger.gameEvent('PlayerResigned', data: {'side': side.name});

      Get.snackbar(
        'Game Over',
        '${side == Side.white ? 'White' : 'Black'} resigned',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error resigning',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Failed to resign: ${e.toString()}');
    }
  }

  /// Offer/accept draw by agreement
  Future<void> agreeDrawn() async {
    try {
      _gameState.setAgreementDraw();
      _updateReactiveState();

      await _saveGameToDatabase();

      AppLogger.gameEvent('DrawByAgreement');

      Get.snackbar(
        'Game Over',
        'Draw by agreement',
        snackPosition: SnackPosition.BOTTOM,
      );
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error setting draw',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
      _setError('Failed to set draw: ${e.toString()}');
    }
  }

  /// Reset game
  void reset() {
    _gameState = GameState(initial: Chess.initial);
    _updateReactiveState();
    _promotionMove.value = null;
    _premove.value = null;
    AppLogger.gameEvent('GameReset');
  }

  /// Get legal moves for chessground (IMap format)
  cg.ValidMoves _makeLegalMoves() {
    final legalMoves = _gameState.position.legalMoves;
    final Map<String, List<String>> validMovesMap = {};

    for (final move in legalMoves) {
      if (move is NormalMove) {
        final fromSquare = _squareToChessgroundSquare(move.from);
        final toSquare = _squareToChessgroundSquare(move.to);
        
        validMovesMap.putIfAbsent(fromSquare, () => []).add(toSquare);
      }
    }

    return IMap(validMovesMap);
  }

  /// Get last move for chessground highlighting
  cg.Move? _getLastMoveForChessground() {
    final lastMoveMeta = _gameState.lastMoveMeta;
    if (lastMoveMeta?.lan == null) return null;
    
    try {
      final move = Move.fromUci(lastMoveMeta!.lan!);
      if (move is NormalMove) {
        return cg.Move(
          from: _squareToChessgroundSquare(move.from),
          to: _squareToChessgroundSquare(move.to),
        );
      }
    } catch (e) {
      // Ignore parsing errors
    }
    
    return null;
  }

  /// Get PGN string of current game
  String getPgnString() {
    if (_currentGame.value == null) return '';

    return _gameState.pgnString(
      headers: {
        'Event': _currentGame.value!.event ?? '?',
        'Site': _currentGame.value!.site ?? '?',
        'Date': _currentGame.value!.date?.toString().split(' ')[0] ?? '????.??.??',
        'Round': _currentGame.value!.round ?? '?',
        'White': _currentGame.value!.whitePlayer.name,
        'Black': _currentGame.value!.blackPlayer.name,
      },
    );
  }

  /// Get captured pieces for a side
  List<Role> getCapturedPieces(Side side) {
    return _gameState.getCapturedPiecesList(side);
  }

  /// Get material count on board for a side
  int getMaterialOnBoard(Side side) {
    return _gameState.materialOnBoard(side);
  }

  /// Save current game manually
  Future<void> saveGame() async {
    await _saveGameToDatabase();
    Get.snackbar(
      'Game Saved',
      'Game saved successfully',
      snackPosition: SnackPosition.BOTTOM,
    );
  }

  /// Flip board orientation
  void flipBoard() {
    _orientation.value = _orientation.value == Side.white ? Side.black : Side.white;
  }

  /// Jump to specific halfmove
  void jumpToHalfmove(int index) {
    final allMoves = _gameState.getMoveObjectsCopy();
    final newState = GameState(initial: Chess.initial);
    
    for (int i = 0; i <= index && i < allMoves.length; i++) {
      newState.play(allMoves[i]);
    }
    
    _gameState = newState;
    _updateReactiveState();
  }

  /// Get move tokens for PGN display
  List<MoveDataModel> get pgnTokens => _gameState.getMoveTokens;

  /// Get current halfmove index
  int get currentHalfmoveIndex => _gameState.currentHalfmoveIndex;

  // ========== Private Methods ==========

  /// Auto-save game after each move
  Future<void> _autoSaveGame() async {
    try {
      await _saveGameToDatabase();
      AppLogger.debug('Game auto-saved', tag: 'GameController');
    } catch (e) {
      AppLogger.warning(
        'Auto-save failed: ${e.toString()}',
        tag: 'GameController',
      );
    }
  }

  /// Save game to database
  Future<void> _saveGameToDatabase() async {
    if (_currentGame.value == null) return;

    try {
      // Sync GameState to Entity
      final syncResult = GameService.syncGameStateToEntity(
        _gameState,
        _currentGame.value!,
      );

      syncResult.fold(
        (failure) {
          AppLogger.error(
            'Failed to sync game state: ${failure.message}',
            tag: 'GameController',
          );
        },
        (updatedGame) async {
          // Update game in database
          final updateResult = await _updateGameUseCase(
            UpdateGameParams(game: updatedGame),
          );

          updateResult.fold(
            (failure) {
              AppLogger.error(
                'Failed to update game: ${failure.message}',
                tag: 'GameController',
              );
            },
            (savedGame) {
              _currentGame.value = savedGame;

              // Cache state
              final stateEntity = GameStateConverter.toEntity(
                _gameState,
                savedGame.uuid,
              );
              _cacheGameStateUseCase(CacheGameStateParams(state: stateEntity));

              AppLogger.database('Game updated successfully');
            },
          );
        },
      );
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error saving game',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameController',
      );
    }
  }

  /// Update all reactive state variables
  void _updateReactiveState() {
    _currentFen.value = _gameState.position.fen;
    _currentTurn.value = _gameState.turn;
    _isGameOver.value = _gameState.isGameOverExtended;
    _gameResult.value = GameService.calculateResult(
      _gameState,
      _gameState.status(),
    );
    _termination.value = _gameState.status();
    _lastMove.value = _getLastMoveForChessground();
    _validMoves.value = _makeLegalMoves();
    _canUndo.value = _gameState.canUndo;
    _canRedo.value = _gameState.canRedo;
    _materialAdvantage.value = _gameState.getMaterialAdvantageSignedForWhite;
    _isCheck.value = _gameState.isCheck;
  }

  /// Convert dartchess Square to chessground square string
  String _squareToChessgroundSquare(Square square) {
    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    return '${files[square.file]}${square.rank + 1}';
  }

  /// Set loading state
  void _setLoading(bool value) {
    _isLoading.value = value;
  }

  /// Set error message
  void _setError(String message) {
    _errorMessage.value = message;
    AppLogger.error(message, tag: 'GameController');
  }

  /// Clear error message
  void _clearError() {
    _errorMessage.value = '';
  }
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 2: ØªØ­Ø¯ÙŠØ« GameScreen - ChessBoard Widget
// lib/presentation/pages/game_screen.dart - ØªØ­Ø¯ÙŠØ« buildChessBoard method

/// Build chess board widget
Widget _buildChessBoard(BuildContext context) {
  return Obx(() {
    return cg.Board(
      size: MediaQuery.of(context).size.width,
      data: cg.BoardData(
        interactableSide: controller.isGameOver 
            ? cg.InteractableSide.none 
            : cg.InteractableSide.both, // Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø± Ø¶Ø¯ Ø§Ù„Ù†ÙØ³
        orientation: controller.orientation == Side.white ? cg.Side.white : cg.Side.black,
        fen: controller.currentFen,
        lastMove: controller.lastMove,
        validMoves: controller.validMoves,
        sideToMove: controller.currentTurn,
        isCheck: controller.isCheck,
        // Game data configuration
        game: cg.GameData(
          playerSide: cg.PlayerSide.both, // Ù…Ù‡Ù… Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø±
          validMoves: controller.validMoves,
          sideToMove: controller.currentTurn,
          isCheck: controller.isCheck,
          promotionMove: controller.promotionMove,
          onMove: controller.onUserMove, // Ø§Ø³ØªØ®Ø¯Ø§Ù… onUserMove Ù…Ø¨Ø§Ø´Ø±Ø©
          onPromotionSelection: controller.onPromotionSelection,
          premovable: (
            onSetPremove: controller.onSetPremove,
            premove: controller.premove,
          ),
        ),
        // Board theme
        settings: cg.BoardSettings(
          colorScheme: cg.BoardColorScheme(
            lightSquare: const Color(0xFFF0D9B5),
            darkSquare: const Color(0xFFB58863),
            lastMove: cg.HighlightDetails(
              solidColor: Colors.yellow.withOpacity(0.5),
            ),
            selected: cg.HighlightDetails(
              solidColor: Colors.green.withOpacity(0.5),
            ),
          ),
          pieceAssets: cg.PieceSet.merida.assets,
          borderRadius: const BorderRadius.all(Radius.circular(4)),
          boxShadow: const [
            BoxShadow(
              color: Colors.black26,
              blurRadius: 10,
              spreadRadius: 2,
            ),
          ],
          enableCoordinates: true,
          animationDuration: const Duration(milliseconds: 250),
          autoQueenPromotion: false,
          dragTargetKind: cg.DragTargetKind.circle,
        ),
      ),
    );
  });
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 3: Ø¥Ø¶Ø§ÙØ© Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ GameController
Ø§Ù„ØµÙ‚ Ù‡Ø°Ø§ ÙÙŠ Ø¢Ø®Ø± GameController (Ù‚Ø¨Ù„ } Ø§Ù„Ø£Ø®ÙŠØ±Ø©):
///Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 3 ÙˆØ§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©:
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 3: Ø¥Ø¶Ø§ÙØ© Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙŠ GameController (ØªÙƒÙ…Ù„Ø©)
Ø§Ù„ØµÙ‚ Ù‡Ø°Ø§ ÙÙŠ Ø¢Ø®Ø± GameController (Ù‚Ø¨Ù„ } Ø§Ù„Ø£Ø®ÙŠØ±Ø©):
/// Helper method to create ValidMoves for chessground from legal moves
  /// Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ø¥Ù†Ø´Ø§Ø¡ ValidMoves Ù„Ù€ chessground Ù…Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠØ©
  static cg.ValidMoves makeLegalMovesForChessground(Position position) {
    final legalMoves = position.legalMoves;
    final Map<String, List<String>> validMovesMap = {};

    for (final move in legalMoves) {
      if (move is NormalMove) {
        final fromSquare = _squareToString(move.from);
        final toSquare = _squareToString(move.to);
        
        validMovesMap.putIfAbsent(fromSquare, () => []).add(toSquare);
      }
    }

    return IMap(validMovesMap);
  }

  /// Convert Square to string for chessground
  /// ØªØ­ÙˆÙŠÙ„ Square Ø¥Ù„Ù‰ Ù†Øµ Ù„Ù€ chessground
  static String _squareToString(Square square) {
    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    return '${files[square.file]}${square.rank + 1}';
  }
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 4: ØªØ­Ø¯ÙŠØ« Ø¯Ø§Ù„Ø© _handleMove ÙÙŠ GameScreen
Ø§Ø³ØªØ¨Ø¯Ù„ Ø¯Ø§Ù„Ø© _handleMove ÙÙŠ game_screen.dart:
// lib/presentation/pages/game_screen.dart

/// Handle move from chessground
/// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ù† chessground
void _handleMove(cg.Move move) {
  // ØªØ­ÙˆÙŠÙ„ Ù…Ù† chessground Move Ø¥Ù„Ù‰ dartchess Square
  final from = _chessgroundSquareToSquare(move.from);
  final to = _chessgroundSquareToSquare(move.to);
  
  // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚Ø© Ù…Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù‚Ø§Ù†ÙˆÙ†ÙŠØ©
  final legalMoves = controller.gameState.position.legalMoves;
  
  for (final legalMove in legalMoves) {
    if (legalMove is NormalMove && 
        legalMove.from == from && 
        legalMove.to == to) {
      
      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØªØ±Ù‚ÙŠØ©
      if (controller._isPromotionPawnMove(legalMove)) {
        // Ø¹Ø±Ø¶ Ù…Ø±Ø¨Ø¹ Ø­ÙˆØ§Ø± Ø§Ù„ØªØ±Ù‚ÙŠØ©
        _showPromotionDialog(from, to);
      } else {
        // ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø±ÙƒØ© Ù…Ø¨Ø§Ø´Ø±Ø©
        controller.onUserMove(legalMove);
      }
      return;
    }
  }
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 5: ØªØ­Ø³ÙŠÙ† Ø¯Ø§Ù„Ø© _updateReactiveState
Ø§Ø³ØªØ¨Ø¯Ù„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ GameController:
/// Update all reactive state variables
/// ØªØ­Ø¯ÙŠØ« Ø¬Ù…ÙŠØ¹ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„ØªÙØ§Ø¹Ù„ÙŠØ©
void _updateReactiveState() {
  _currentFen.value = _gameState.position.fen;
  _currentTurn.value = _gameState.turn;
  _isGameOver.value = _gameState.isGameOverExtended;
  
  // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø©
  final termination = GameService.checkGameTermination(_gameState).fold(
    (failure) => GameTermination.ongoing,
    (term) => term,
  );
  _termination.value = termination;
  _gameResult.value = GameService.calculateResult(_gameState, termination);
  
  // ØªØ­Ø¯ÙŠØ« Ø¢Ø®Ø± Ø­Ø±ÙƒØ© Ù„Ù„Ø¥Ø¶Ø§Ø¡Ø©
  _lastMove.value = _getLastMoveForChessground();
  
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„ØµØ§Ù„Ø­Ø©
  _validMoves.value = _makeLegalMoves();
  
  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ØªØ±Ø§Ø¬Ø¹/Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø©
  _canUndo.value = _gameState.canUndo && !_isGameOver.value;
  _canRedo.value = _gameState.canRedo && !_isGameOver.value;
  
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ù…Ø§Ø¯ÙŠ
  _materialAdvantage.value = _gameState.getMaterialAdvantageSignedForWhite;
  
  // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„ÙƒØ´
  _isCheck.value = _gameState.isCheck;
  
  // Ø¥Ø¬Ø¨Ø§Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«
  update();
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 6: Ø¥ØµÙ„Ø§Ø­ GameData ÙÙŠ ChessBoard
Ø§Ø³ØªØ¨Ø¯Ù„ ÙÙŠ game_screen.dart Ù‚Ø³Ù… ChessBoard Ø¨Ø§Ù„ÙƒØ§Ù…Ù„:
// lib/presentation/pages/game_screen.dart - buildChessBoard method (COMPLETE)

/// Build chess board widget
/// Ø¨Ù†Ø§Ø¡ Ø¹Ù†ØµØ± Ø±Ù‚Ø¹Ø© Ø§Ù„Ø´Ø·Ø±Ù†Ø¬
Widget _buildChessBoard(BuildContext context) {
  return Obx(() {
    return cg.Board(
      size: MediaQuery.of(context).size.width,
      data: cg.BoardData(
        interactableSide: controller.isGameOver 
            ? cg.InteractableSide.none 
            : cg.InteractableSide.both,
        orientation: controller.orientation == Side.white 
            ? cg.Side.white 
            : cg.Side.black,
        fen: controller.currentFen,
        lastMove: controller.lastMove,
        validMoves: controller.validMoves,
        sideToMove: controller.currentTurn,
        isCheck: controller.isCheck,
        settings: cg.BoardSettings(
          colorScheme: cg.BoardColorScheme(
            lightSquare: const Color(0xFFF0D9B5),
            darkSquare: const Color(0xFFB58863),
            lastMove: cg.HighlightDetails(
              solidColor: Colors.yellow.withOpacity(0.5),
            ),
            selected: cg.HighlightDetails(
              solidColor: Colors.green.withOpacity(0.5),
            ),
          ),
          pieceAssets: cg.PieceSet.merida.assets,
          borderRadius: const BorderRadius.all(Radius.circular(4)),
          boxShadow: const [
            BoxShadow(
              color: Colors.black26,
              blurRadius: 10,
              spreadRadius: 2,
            ),
          ],
          enableCoordinates: true,
          animationDuration: const Duration(milliseconds: 250),
          autoQueenPromotion: false,
          dragTargetKind: cg.DragTargetKind.circle,
          dragFeedbackScale: 2.0,
          pieceShiftMethod: cg.PieceShiftMethod.either,
        ),
      ),
      // Ø§Ø³ØªØ®Ø¯Ø§Ù… game Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† onMove Ù…Ø¨Ø§Ø´Ø±Ø©
      game: cg.GameData(
        playerSide: controller.isGameOver 
            ? cg.PlayerSide.none 
            : cg.PlayerSide.both, // Ù…Ù‡Ù… Ø¬Ø¯Ø§Ù‹ Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø±
        validMoves: controller.validMoves,
        sideToMove: controller.currentTurn,
        isCheck: controller.isCheck,
        promotionMove: controller.promotionMove,
        onMove: (move, {isDrop}) {
          controller.onUserMove(move, isDrop: isDrop);
        },
        onPromotionSelection: controller.onPromotionSelection,
        premovable: (
          onSetPremove: controller.onSetPremove,
          premove: controller.premove,
        ),
      ),
    );
  });
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 7: Ø¥Ø¶Ø§ÙØ© Ø²Ø± Flip Board ÙÙŠ GameControls
ÙÙŠ game_controls_widget.dartØŒ Ø§Ø³ØªØ¨Ø¯Ù„ Ø¯Ø§Ù„Ø© _flipBoard:
/// Flip board orientation
/// Ù‚Ù„Ø¨ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø±Ù‚Ø¹Ø©
void _flipBoard() {
  final controller = Get.find<GameController>();
  controller.flipBoard();
  Get.snackbar(
    'Board Flipped',
    'Board orientation changed',
    snackPosition: SnackPosition.BOTTOM,
    duration: const Duration(seconds: 1),
  );
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 8: ØªØ­Ø¯ÙŠØ« Move List Widget
Ø§Ø³ØªØ¨Ø¯Ù„ ÙÙŠ move_list_widget.dart:
// lib/presentation/widgets/move_list_widget.dart

/// Handle move click for navigation
/// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ù„ØªÙ†Ù‚Ù„
void _handleMoveClick(int moveIndex) {
  controller.jumpToHalfmove(moveIndex);
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 9: Ø¥Ø¶Ø§ÙØ© dependØ§ency Ù„Ù€ fast_immutable_collections
ÙÙŠ pubspec.yamlØŒ Ø£Ø¶Ù:
dependencies:
  # ... existing dependencies
  
  # For IMap (chessground ValidMoves)
  fast_immutable_collections: ^10.2.4
Ø«Ù… Ø´ØºÙ„:
flutter pub get
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 10: ØªØ­Ø¯ÙŠØ« GameService Ù„Ø¯Ø¹Ù… Ø§Ù„Ø­Ø±ÙƒØ§Øª
ÙÙŠ game_service.dartØŒ Ø£Ø¶Ù Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø©:
// lib/domain/services/game_service.dart (ADD THIS)

/// Make ValidMoves map for chessground from Position
/// Ø¥Ù†Ø´Ø§Ø¡ Ø®Ø±ÙŠØ·Ø© ValidMoves Ù„Ù€ chessground Ù…Ù† Position
static Map<String, List<String>> makeValidMovesMap(Position position) {
  final legalMoves = position.legalMoves;
  final Map<String, List<String>> validMovesMap = {};

  for (final move in legalMoves) {
    if (move is NormalMove) {
      final fromSquare = _squareToChessgroundSquare(move.from);
      final toSquare = _squareToChessgroundSquare(move.to);
      
      validMovesMap.putIfAbsent(fromSquare, () => []).add(toSquare);
    }
  }

  return validMovesMap;
}

/// Convert Square to chessground square notation
/// ØªØ­ÙˆÙŠÙ„ Square Ø¥Ù„Ù‰ ØªØ¯ÙˆÙŠÙ† Ù…Ø±Ø¨Ø¹ chessground
static String _squareToChessgroundSquare(Square square) {
  const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
  return '${files[square.file]}${square.rank + 1}';
}
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 11: Ø¥ØµÙ„Ø§Ø­ PopScope ÙÙŠ GameScreen
Ø§Ø³ØªØ¨Ø¯Ù„ PopScope ÙÙŠ game_screen.dart:
// lib/presentation/pages/game_screen.dart - ÙÙŠ buildChessBoard

PopScope(
  canPop: controller.isGameOver,
  onPopInvokedWithResult: (didPop, result) async {
    if (didPop) return;
    
    if (controller.isGameOver) {
      Get.back();
      return;
    }

    // Ø¹Ø±Ø¶ ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø®Ø±ÙˆØ¬
    final shouldExit = await Get.dialog<bool>(
      AlertDialog(
        title: const Text('Exit Game'),
        content: const Text('Do you want to exit? The game will be saved.'),
        actions: [
          TextButton(
            onPressed: () => Get.back(result: false),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Get.back(result: true),
            child: const Text('Exit'),
          ),
        ],
      ),
    );

    if (shouldExit == true) {
      await controller.saveGame();
      if (context.mounted) {
        Get.back();
      }
    }
  },
  child: /* ChessBoard Widget */
)
ğŸ“ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ 12: ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªØ±Ù‚ÙŠØ© ÙÙŠ GameController
Ø£Ø¶Ù Ù‡Ø°Ù‡ Ø§Ù„Ø¯Ø§Ù„Ø© ÙÙŠ GameController:
/// Cancel promotion
/// Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ±Ù‚ÙŠØ©
void cancelPromotion() {
  _promotionMove.value = null;
  update();
}
ğŸ“‹ Ù…Ù„Ø®Øµ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª:
Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
Ø§Ù„Ù…Ù„Ù
Ø§Ù„Ù…ÙˆÙ‚Ø¹
Ø§Ù„ØºØ±Ø¶
âœ… 1
game_controller.dart
ÙƒØ§Ù…Ù„
Ø¥Ø¹Ø§Ø¯Ø© ÙƒØªØ§Ø¨Ø© Ø´Ø§Ù…Ù„Ø© Ù„Ø¯Ø¹Ù… chessground
âœ… 2
game_screen.dart
_buildChessBoard
ØªØ­Ø¯ÙŠØ« Board widget
âœ… 3
game_controller.dart
Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙƒÙ„Ø§Ø³
Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø©
âœ… 4
game_screen.dart
_handleMove
Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø­Ø±ÙƒØ§Øª
âœ… 5
game_controller.dart
_updateReactiveState
ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªØ­Ø¯ÙŠØ«
âœ… 6
game_screen.dart
_buildChessBoard
Ø¥ØµÙ„Ø§Ø­ GameData
âœ… 7
game_controls_widget.dart
_flipBoard
Ù‚Ù„Ø¨ Ø§Ù„Ø±Ù‚Ø¹Ø©
âœ… 8
move_list_widget.dart
_handleMoveClick
Ø§Ù„ØªÙ†Ù‚Ù„ Ø¨ÙŠÙ† Ø§Ù„Ø­Ø±ÙƒØ§Øª
âœ… 9
pubspec.yaml
dependencies
Ø¥Ø¶Ø§ÙØ© IMap
âœ… 10
game_service.dart
Ù†Ù‡Ø§ÙŠØ© Ø§Ù„ÙƒÙ„Ø§Ø³
Ø¯Ø§Ù„Ø© ValidMoves
âœ… 11
game_screen.dart
PopScope
ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø®Ø±ÙˆØ¬
âœ… 12
game_controller.dart
methods
Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ØªØ±Ù‚ÙŠØ©
ğŸ¯ Ø§Ù„ÙØ±ÙˆÙ‚Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¹Ù† Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ù…Ù„ØµÙ‚:
âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… NormalMove Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† UCI string
âœ… IMap Ù„Ù„Ù€ ValidMoves Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Map Ø¹Ø§Ø¯ÙŠ
âœ… GameData structure ÙƒØ§Ù…Ù„ Ù„Ù€ chessground
âœ… Premove support ÙƒØ§Ù…Ù„
âœ… Promotion dialog Ù…Ø­Ø³Ù‘Ù†
âœ… Board orientation Ù‚Ø§Ø¨Ù„ Ù„Ù„ØªØ¨Ø¯ÙŠÙ„
âœ… Auto-save Ø¨Ø¹Ø¯ ÙƒÙ„ Ø­Ø±ÙƒØ©
âœ… Clean Architecture Ù…Ø­ÙÙˆØ¸Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
ğŸš€ Ø§Ù„Ø®Ø·ÙˆØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©:
# 1. Update dependencies
flutter pub get

# 2. Generate code if needed
flutter pub run build_runner build --delete-conflicting-outputs

# 3. Run the app
flutter run
âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©:
PlayerSide.both Ø¶Ø±ÙˆØ±ÙŠ Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø± (Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙŠØ­Ø±Ùƒ Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ø¨ÙŠØ¶Ø§Ø¡ ÙˆØ§Ù„Ø³ÙˆØ¯Ø§Ø¡)
interactableSide ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† InteractableSide.both ÙˆÙ„ÙŠØ³ Ø­Ø³Ø¨ Ø§Ù„Ø¯ÙˆØ±
ValidMoves ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† IMap ÙˆÙ„ÙŠØ³ Map Ø¹Ø§Ø¯ÙŠ
onMove ÙŠØ³ØªÙ‚Ø¨Ù„ NormalMove Ù…Ø¨Ø§Ø´Ø±Ø© Ù…Ù† chessground
Promotion ÙŠØ­ØªØ§Ø¬ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø®Ø§ØµØ© Ù‚Ø¨Ù„ ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø±ÙƒØ©
Ø§Ù„Ø¢Ù† Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ Ù…Ø¹ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„Ø¹Ø¨ Ø§Ù„Ø­Ø±! ğŸ‰