 uestPlayer(name);
final entity = model.toEntity();
AppLogger.info(
    'Repository: Guest player ready',
    tag: 'PlayerRepository',
  );

  return Right(entity);
} catch (e, stackTrace) {
  AppLogger.error(
    'Repository: Failed to get/create guest player',
    error: e,
    stackTrace: stackTrace,
    tag: 'PlayerRepository',
  );

  return Left(
    DatabaseFailure(
      message: 'Failed to get/create guest player: ${e.toString()}',
      details: e,
    ),
  );
}
}
@override
Stream<Either<Failure, PlayerEntity>> watchPlayer(String uuid) {
try {
AppLogger.info(
'Repository: Watching player $uuid',
tag: 'PlayerRepository',
);
return localDataSource.watchPlayer(uuid).map((model) {
    if (model == null) {
      return Left(
        NotFoundFailure(message: 'Player not found: $uuid'),
      );
    }
    return Right(model.toEntity());
  }).handleError((error, stackTrace) {
    AppLogger.error(
      'Repository: Error watching player',
      error: error,
      stackTrace: stackTrace,
      tag: 'PlayerRepository',
    );
    return Left(
      DatabaseFailure(
        message: 'Failed to watch player: ${error.toString()}',
      ),
    );
  });
} catch (e, stackTrace) {
  AppLogger.error(
    'Repository: Failed to setup player watch',
    error: e,
    stackTrace: stackTrace,
    tag: 'PlayerRepository',
  );

  return Stream.value(
    Left(
      DatabaseFailure(
        message: 'Failed to watch player: ${e.toString()}',
      ),
    ),
  );
}
}
}
```dart
// lib/data/repositories/game_state_repository_impl.dart

import 'package:dartz/dartz.dart';
import '../../core/errors/failures.dart';
import '../../core/utils/logger.dart';
import '../../domain/entities/game_state_entity.dart';
import '../../domain/repositories/game_state_repository.dart';
import '../datasources/cache/game_state_cache_datasource.dart';
import '../models/game_state_model.dart';

/// Implementation of GameStateRepository
/// تنفيذ مستودع حالة اللعبة
class GameStateRepositoryImpl implements GameStateRepository {
  final GameStateCacheDataSource cacheDataSource;

  GameStateRepositoryImpl({required this.cacheDataSource});

  @override
  Future<Either<Failure, void>> cacheGameState(GameStateEntity state) async {
    try {
      AppLogger.debug(
        'Repository: Caching game state ${state.gameUuid}',
        tag: 'GameStateRepository',
      );

      // Convert entity to model
      final model = state.toModel();

      // Cache using data source
      await cacheDataSource.cacheGameState(model);

      AppLogger.debug(
        'Repository: Game state cached successfully',
        tag: 'GameStateRepository',
      );

      return const Right(null);
    } catch (e, stackTrace) {
      AppLogger.error(
        'Repository: Failed to cache game state',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameStateRepository',
      );

      return Left(
        CacheFailure(
          message: 'Failed to cache game state: ${e.toString()}',
          details: e,
        ),
      );
    }
  }

  @override
  Future<Either<Failure, GameStateEntity>> getCachedGameState(
    String gameUuid,
  ) async {
    try {
      AppLogger.debug(
        'Repository: Retrieving cached game state $gameUuid',
        tag: 'GameStateRepository',
      );

      // Fetch from cache
      final model = await cacheDataSource.getCachedGameState(gameUuid);

      // Convert to entity
      final entity = model.toEntity();

      AppLogger.debug(
        'Repository: Game state retrieved from cache',
        tag: 'GameStateRepository',
      );

      return Right(entity);
    } catch (e, stackTrace) {
      AppLogger.error(
        'Repository: Failed to retrieve cached game state',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameStateRepository',
      );

      if (e.toString().contains('not found')) {
        return Left(
          NotFoundFailure(
            message: 'Game state not found in cache: $gameUuid',
          ),
        );
      }

      return Left(
        CacheFailure(
          message: 'Failed to retrieve cached game state: ${e.toString()}',
          details: e,
        ),
      );
    }
  }

  @override
  Future<Either<Failure, void>> removeCachedGameState(String gameUuid) async {
    try {
      AppLogger.debug(
        'Repository: Removing cached game state $gameUuid',
        tag: 'GameStateRepository',
      );

      await cacheDataSource.removeCachedGameState(gameUuid);

      AppLogger.debug(
        'Repository: Game state removed from cache',
        tag: 'GameStateRepository',
      );

      return const Right(null);
    } catch (e, stackTrace) {
      AppLogger.error(
        'Repository: Failed to remove cached game state',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameStateRepository',
      );

      return Left(
        CacheFailure(
          message: 'Failed to remove cached game state: ${e.toString()}',
          details: e,
        ),
      );
    }
  }

  @override
  Future<Either<Failure, Map<String, GameStateEntity>>> getAllActiveStates() async {
    try {
      AppLogger.debug(
        'Repository: Retrieving all active game states',
        tag: 'GameStateRepository',
      );

      final modelsMap = await cacheDataSource.getAllActiveStates();

      // Convert all models to entities
      final entitiesMap = modelsMap.map(
        (key, model) => MapEntry(key, model.toEntity()),
      );

      AppLogger.debug(
        'Repository: Retrieved ${entitiesMap.length} active game states',
        tag: 'GameStateRepository',
      );

      return Right(entitiesMap);
    } catch (e, stackTrace) {
      AppLogger.error(
        'Repository: Failed to retrieve all active states',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameStateRepository',
      );

      return Left(
        CacheFailure(
          message: 'Failed to retrieve active states: ${e.toString()}',
          details: e,
        ),
      );
    }
  }

  @override
  Future<Either<Failure, void>> clearAllCachedStates() async {
    try {
      AppLogger.debug(
        'Repository: Clearing all cached game states',
        tag: 'GameStateRepository',
      );

      await cacheDataSource.clearAllCachedStates();

      AppLogger.debug(
        'Repository: All cached game states cleared',
        tag: 'GameStateRepository',
      );

      return const Right(null);
    } catch (e, stackTrace) {
      AppLogger.error(
        'Repository: Failed to clear all cached states',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameStateRepository',
      );

      return Left(
        CacheFailure(
          message: 'Failed to clear cached states: ${e.toString()}',
          details: e,
        ),
      );
    }
  }

  @override
  Future<Either<Failure, bool>> hasGameState(String gameUuid) async {
    try {
      final exists = await cacheDataSource.hasGameState(gameUuid);

      AppLogger.debug(
        'Repository: Game state exists in cache: $exists',
        tag: 'GameStateRepository',
      );

      return Right(exists);
    } catch (e, stackTrace) {
      AppLogger.error(
        'Repository: Failed to check game state existence',
        error: e,
        stackTrace: stackTrace,
        tag: 'GameStateRepository',
      );

      return Left(
        CacheFailure(
          message: 'Failed to check game state existence: ${e.toString()}',
          details: e,
        ),
      );
    }
  }
}
17. Dependency Injection Setup
// lib/di/injection_container.dart

import 'package:get_it/get_it.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import '../core/utils/logger.dart';
import '../data/collections/chess_game.dart';
import '../data/collections/player.dart';
import '../data/datasources/cache/game_state_cache_datasource.dart';
import '../data/datasources/local/chess_game_local_datasource.dart';
import '../data/datasources/local/player_local_datasource.dart';
import '../data/repositories/chess_game_repository_impl.dart';
import '../data/repositories/game_state_repository_impl.dart';
import '../data/repositories/player_repository_impl.dart';
import '../domain/repositories/chess_game_repository.dart';
import '../domain/repositories/game_state_repository.dart';
import '../domain/repositories/player_repository.dart';
import '../domain/usecases/game/delete_game_usecase.dart';
import '../domain/usecases/game/get_all_games_usecase.dart';
import '../domain/usecases/game/get_game_by_uuid_usecase.dart';
import '../domain/usecases/game/get_recent_games_usecase.dart';
import '../domain/usecases/game/save_game_usecase.dart';
import '../domain/usecases/game/update_game_usecase.dart';
import '../domain/usecases/game_state/cache_game_state_usecase.dart';
import '../domain/usecases/game_state/get_cached_game_state_usecase.dart';
import '../domain/usecases/game_state/remove_cached_game_state_usecase.dart';
import '../domain/usecases/player/get_or_create_guest_player_usecase.dart';
import '../domain/usecases/player/get_player_by_uuid_usecase.dart';
import '../domain/usecases/player/save_player_usecase.dart';
import '../domain/usecases/player/update_player_rating_usecase.dart';
import '../domain/usecases/player/update_player_usecase.dart';

/// Service locator instance
/// مثيل محدد موقع الخدمة
final sl = GetIt.instance;

/// Initialize all dependencies
/// تهيئة جميع التبعيات
class InjectionContainer {
  /// Setup all dependencies
  /// إعداد جميع التبعيات
  static Future<void> init() async {
    try {
      AppLogger.info('Initializing dependency injection', tag: 'DI');

      // ========== External Dependencies ==========
      await _initExternalDependencies();

      // ========== Data Sources ==========
      _initDataSources();

      // ========== Repositories ==========
      _initRepositories();

      // ========== Use Cases ==========
      _initUseCases();

      // ========== Controllers (will be initialized via GetX) ==========
      // Controllers are registered on-demand by GetX

      AppLogger.info('Dependency injection initialized successfully', tag: 'DI');
    } catch (e, stackTrace) {
      AppLogger.error(
        'Failed to initialize dependency injection',
        error: e,
        stackTrace: stackTrace,
        tag: 'DI',
      );
      rethrow;
    }
  }

  /// Initialize external dependencies (Database, etc.)
  /// تهيئة التبعيات الخارجية (قاعدة البيانات، إلخ)
  static Future<void> _initExternalDependencies() async {
    AppLogger.info('Initializing Isar database', tag: 'DI');

    // Get application directory
    final dir = await getApplicationDocumentsDirectory();

    // Open Isar instance
    final isar = await Isar.open(
      [
        PlayerSchema,
        ChessGameSchema,
      ],
      directory: dir.path,
      name: 'chess_game_db',
    );

    // Register Isar as singleton
    sl.registerLazySingleton<Isar>(() => isar);

    AppLogger.info('Isar database initialized', tag: 'DI');
  }

  /// Initialize data sources
  /// تهيئة مصادر البيانات
  static void _initDataSources() {
    AppLogger.debug('Registering data sources', tag: 'DI');

    // Local data sources
    sl.registerLazySingleton<ChessGameLocalDataSource>(
      () => ChessGameLocalDataSourceImpl(isar: sl()),
    );

    sl.registerLazySingleton<PlayerLocalDataSource>(
      () => PlayerLocalDataSourceImpl(isar: sl()),
    );

    // Cache data source
    sl.registerLazySingleton<GameStateCacheDataSource>(
      () => GameStateCacheDataSourceImpl(),
    );

    AppLogger.debug('Data sources registered', tag: 'DI');
  }

  /// Initialize repositories
  /// تهيئة المستودعات
  static void _initRepositories() {
    AppLogger.debug('Registering repositories', tag: 'DI');

    sl.registerLazySingleton<ChessGameRepository>(
      () => ChessGameRepositoryImpl(localDataSource: sl()),
    );

    sl.registerLazySingleton<PlayerRepository>(
      () => PlayerRepositoryImpl(localDataSource: sl()),
    );

    sl.registerLazySingleton<GameStateRepository>(
      () => GameStateRepositoryImpl(cacheDataSource: sl()),
    );

    AppLogger.debug('Repositories registered', tag: 'DI');
  }

  /// Initialize use cases
  /// تهيئة حالات الاستخدام
  static void _initUseCases() {
    AppLogger.debug('Registering use cases', tag: 'DI');

    // Game use cases
    sl.registerLazySingleton(() => SaveGameUseCase(sl()));
    sl.registerLazySingleton(() => UpdateGameUseCase(sl()));
    sl.registerLazySingleton(() => GetGameByUuidUseCase(sl()));
    sl.registerLazySingleton(() => GetAllGamesUseCase(sl()));
    sl.registerLazySingleton(() => GetRecentGamesUseCase(sl()));
    sl.registerLazySingleton(() => DeleteGameUseCase(sl()));

    // Player use cases
    sl.registerLazySingleton(() => SavePlayerUseCase(sl()));
    sl.registerLazySingleton(() => UpdatePlayerUseCase(sl()));
    sl.registerLazySingleton(() => GetPlayerByUuidUseCase(sl()));
    sl.registerLazySingleton(() => UpdatePlayerRatingUseCase(sl()));
    sl.registerLazySingleton(() => GetOrCreateGuestPlayerUseCase(sl()));

    // GameState use cases
    sl.registerLazySingleton(() => CacheGameStateUseCase(sl()));
    sl.registerLazySingleton(() => GetCachedGameStateUseCase(sl()));
    sl.registerLazySingleton(() => RemoveCachedGameStateUseCase(sl()));

    AppLogger.debug('Use cases registered', tag: 'DI');
  }

  /// Clean up resources
  /// تنظيف الموارد
  static Future<void> dispose() async {
    try {
      AppLogger.info('Disposing dependency injection', tag: 'DI');

      // Close Isar
      if (sl.isRegistered<Isar>()) {
        final isar = sl<Isar>();
        await isar.close();
      }

      // Reset GetIt
      await sl.reset();

      AppLogger.info('Dependency injection disposed', tag: 'DI');
    } catch (e, stackTrace) {
      AppLogger.error(
        'Error disposing dependency injection',
        error: e,
        stackTrace: stackTrace,
        tag: 'DI',
      );
    }
  }
}
18. Main App Initialization
// lib/main.dart

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'core/utils/logger.dart';
import 'di/injection_container.dart';

void main() async {
  // Ensure Flutter is initialized
  WidgetsFlutterBinding.ensureInitialized();

  try {
    AppLogger.info('Starting Chess Game Application', tag: 'Main');

    // Initialize dependency injection
    await InjectionContainer.init();

    AppLogger.info('Application initialized successfully', tag: 'Main');

    // Run the app
    runApp(const MyApp());
  } catch (e, stackTrace) {
    AppLogger.error(
      'Failed to start application',
      error: e,
      stackTrace: stackTrace,
      tag: 'Main',
    );

    // Show error screen or rethrow
    rethrow;
  }
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      title: 'Chess Game',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.brown),
        useMaterial3: true,
      ),
      // Initial route will be set in next part
      home: const Scaffold(
        body: Center(
          child: Text('Chess Game App - Ready!'),
        ),
      ),
    );
  }
}
اكمل للجزء السادس (Presentation Layer - Controller & UI Integration)
الجزء السابع: UI Pages & Widgets
21. Presentation Layer - Game Screen
// lib/presentation/pages/game_screen.dart

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:chessground/chessground.dart' as cg;
import 'package:dartchess/dartchess.dart';
import '../controllers/game_controller.dart';
import '../widgets/captured_pieces_widget.dart';
import '../widgets/move_list_widget.dart';
import '../widgets/game_info_widget.dart';
import '../widgets/game_controls_widget.dart';

/// Main game screen displaying the chess board and game controls
/// شاشة اللعبة الرئيسية التي تعرض رقعة الشطرنج وعناصر التحكم
class GameScreen extends GetView<GameController> {
  const GameScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: _buildAppBar(context),
      body: SafeArea(
        child: Obx(() {
          // Show loading indicator
          if (controller.isLoading) {
            return const Center(
              child: CircularProgressIndicator(),
            );
          }

          // Show error message
          if (controller.errorMessage.isNotEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    size: 64,
                    color: Colors.red,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    controller.errorMessage,
                    style: const TextStyle(fontSize: 16),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () => Get.back(),
                    child: const Text('Go Back'),
                  ),
                ],
              ),
            );
          }

          // Show game board
          return OrientationBuilder(
            builder: (context, orientation) {
              if (orientation == Orientation.portrait) {
                return _buildPortraitLayout(context);
              } else {
                return _buildLandscapeLayout(context);
              }
            },
          );
        }),
      ),
    );
  }

  /// Build app bar
  /// بناء شريط التطبيق
  PreferredSizeWidget _buildAppBar(BuildContext context) {
    return AppBar(
      title: Obx(() {
        final game = controller.currentGame;
        if (game == null) return const Text('Chess Game');

        return Text(
          '${game.whitePlayer.name} vs ${game.blackPlayer.name}',
          style: const TextStyle(fontSize: 16),
        );
      }),
      actions: [
        // Save button
        IconButton(
          icon: const Icon(Icons.save),
          tooltip: 'Save Game',
          onPressed: () => controller.saveGame(),
        ),
        // Settings button
        IconButton(
          icon: const Icon(Icons.settings),
          tooltip: 'Settings',
          onPressed: () => _showSettingsDialog(context),
        ),
        // Menu button
        PopupMenuButton<String>(
          onSelected: (value) => _handleMenuAction(value, context),
          itemBuilder: (context) => [
            const PopupMenuItem(
              value: 'new_game',
              child: Text('New Game'),
            ),
            const PopupMenuItem(
              value: 'resign',
              child: Text('Resign'),
            ),
            const PopupMenuItem(
              value: 'draw',
              child: Text('Offer Draw'),
            ),
            const PopupMenuItem(
              value: 'export_pgn',
              child: Text('Export PGN'),
            ),
          ],
        ),
      ],
    );
  }

  /// Build portrait layout
  /// بناء تخطيط الوضع العمودي
  Widget _buildPortraitLayout(BuildContext context) {
    return Column(
      children: [
        // Top player info and captured pieces
        _buildPlayerSection(context, Side.black, isTop: true),
        
        // Chess board
        Expanded(
          child: Center(
            child: AspectRatio(
              aspectRatio: 1.0,
              child: _buildChessBoard(context),
            ),
          ),
        ),
        
        // Bottom player info and captured pieces
        _buildPlayerSection(context, Side.white, isTop: false),
        
        // Game controls
        const GameControlsWidget(),
        
        // Move list (collapsible)
        _buildMoveListSection(context),
      ],
    );
  }

  /// Build landscape layout
  /// بناء تخطيط الوضع الأفقي
  Widget _buildLandscapeLayout(BuildContext context) {
    return Row(
      children: [
        // Left side: Game info and move list
        Expanded(
          flex: 3,
          child: Column(
            children: [
              const GameInfoWidget(),
              const Divider(),
              const Expanded(child: MoveListWidget()),
              const Divider(),
              const GameControlsWidget(),
            ],
          ),
        ),
        
        // Center: Chess board
        Expanded(
          flex: 5,
          child: Column(
            children: [
              _buildPlayerSection(context, Side.black, isTop: true),
              Expanded(
                child: Center(
                  child: AspectRatio(
                    aspectRatio: 1.0,
                    child: _buildChessBoard(context),
                  ),
                ),
              ),
              _buildPlayerSection(context, Side.white, isTop: false),
            ],
          ),
        ),
        
        // Right side: Captured pieces
        Expanded(
          flex: 2,
          child: Column(
            children: [
              const Padding(
                padding: EdgeInsets.all(8.0),
                child: Text(
                  'Captured Pieces',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              Expanded(
                child: CapturedPiecesWidget(side: Side.white),
              ),
              const Divider(),
              Expanded(
                child: CapturedPiecesWidget(side: Side.black),
              ),
            ],
          ),
        ),
      ],
    );
  }

  /// Build player section with info and captured pieces
  /// بناء قسم اللاعب مع المعلومات والقطع المأسورة
  Widget _buildPlayerSection(BuildContext context, Side side, {required bool isTop}) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: isTop ? Colors.grey[200] : Colors.grey[100],
        border: Border(
          bottom: isTop ? const BorderSide(color: Colors.grey) : BorderSide.none,
          top: !isTop ? const BorderSide(color: Colors.grey) : BorderSide.none,
        ),
      ),
      child: Row(
        children: [
          // Player avatar
          CircleAvatar(
            backgroundColor: side == Side.white ? Colors.white : Colors.black,
            child: Text(
              side == Side.white ? 'W' : 'B',
              style: TextStyle(
                color: side == Side.white ? Colors.black : Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          const SizedBox(width: 12),
          
          // Player name and turn indicator
          Expanded(
            child: Obx(() {
              final game = controller.currentGame;
              final player = side == Side.white 
                  ? game?.whitePlayer 
                  : game?.blackPlayer;
              
              final isCurrentTurn = controller.currentTurn == side;
              
              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    children: [
                      Text(
                        player?.name ?? 'Unknown',
                        style: TextStyle(
                          fontSize: 16,
                          fontWeight: isCurrentTurn 
                              ? FontWeight.bold 
                              : FontWeight.normal,
                        ),
                      ),
                      if (isCurrentTurn) ...[
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 6,
                            vertical: 2,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.green,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: const Text(
                            'Turn',
                            style: TextStyle(
                              color: Colors.white,
                              fontSize: 10,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                  Text(
                    'Rating: ${player?.playerRating ?? 1200}',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  ),
                ],
              );
            }),
          ),
          
          // Captured pieces preview
          Obx(() {
            final capturedPieces = controller.getCapturedPieces(side);
            if (capturedPieces.isEmpty) {
              return const SizedBox(width: 100);
            }
            
            return SizedBox(
              width: 100,
              child: CapturedPiecesWidget(
                side: side,
                compact: true,
              ),
            );
          }),
        ],
      ),
    );
  }

  /// Build chess board widget
  /// بناء عنصر رقعة الشطرنج
  Widget _buildChessBoard(BuildContext context) {
    return Obx(() {
      final position = controller.gameState.position;
      
      return cg.Board(
        size: MediaQuery.of(context).size.width,
        data: cg.BoardData(
          interactableSide: controller.isGameOver 
              ? cg.InteractableSide.none 
              : _getInteractableSide(),
          orientation: cg.Side.white,
          fen: controller.currentFen,
          lastMove: _getLastMove(),
          validMoves: _getValidMoves(),
          onMove: (move, {isDrop}) => _handleMove(move),
          // Board theme
          settings: cg.BoardSettings(
            colorScheme: cg.BoardColorScheme(
              lightSquare: const Color(0xFFF0D9B5),
              darkSquare: const Color(0xFFB58863),
              lastMove: cg.HighlightDetails(
                solidColor: Colors.yellow.withOpacity(0.5),
              ),
              selected: cg.HighlightDetails(
                solidColor: Colors.green.withOpacity(0.5),
              ),
            ),
            pieceAssets: cg.PieceSet.merida.assets,
            borderRadius: const BorderRadius.all(Radius.circular(4)),
            boxShadow: const [
              BoxShadow(
                color: Colors.black26,
                blurRadius: 10,
                spreadRadius: 2,
              ),
            ],
          ),
        ),
      );
    });
  }

  /// Build move list section (collapsible)
  /// بناء قسم قائمة الحركات (قابل للطي)
  Widget _buildMoveListSection(BuildContext context) {
    return Container(
      constraints: const BoxConstraints(maxHeight: 200),
      decoration: BoxDecoration(
        color: Colors.grey[100],
        border: const Border(
          top: BorderSide(color: Colors.grey),
        ),
      ),
      child: Column(
        children: [
          // Header
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'Move History',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                Obx(() {
                  final moves = controller.gameState.getMoveTokens;
                  return Text(
                    '${moves.length} moves',
                    style: TextStyle(
                      fontSize: 12,
                      color: Colors.grey[600],
                    ),
                  );
                }),
              ],
            ),
          ),
          
          // Move list
          const Expanded(
            child: MoveListWidget(),
          ),
        ],
      ),
    );
  }

  /// Get interactable side for chessground
  /// الحصول على الجانب القابل للتفاعل لـ chessground
  cg.InteractableSide _getInteractableSide() {
    if (controller.isGameOver) return cg.InteractableSide.none;
    
    // Allow moves for current turn
    return controller.currentTurn == Side.white 
        ? cg.InteractableSide.white 
        : cg.InteractableSide.black;
  }

  /// Get last move for highlighting
  /// الحصول على آخر حركة للإضاءة
  cg.Move? _getLastMove() {
    final lastMove = controller.lastMove;
    if (lastMove?.lan == null) return null;
    
    try {
      final move = Move.fromUci(lastMove!.lan!);
      if (move is NormalMove) {
        return cg.Move(
          from: _squareToChessgroundSquare(move.from),
          to: _squareToChessgroundSquare(move.to),
        );
      }
    } catch (e) {
      // Ignore parsing errors
    }
    
    return null;
  }

  /// Get valid moves for chessground
  /// الحصول على الحركات الصالحة لـ chessground
  cg.ValidMoves _getValidMoves() {
    final legalMoves = controller.getLegalMoves();
    final validMoves = <String, List<String>>{};
    
    for (final move in legalMoves) {
      if (move is NormalMove) {
        final fromSquare = _squareToChessgroundSquare(move.from);
        final toSquare = _squareToChessgroundSquare(move.to);
        
        validMoves.putIfAbsent(fromSquare, () => []).add(toSquare);
      }
    }
    
    return cg.ValidMoves(validMoves);
  }

  /// Handle move from chessground
  /// معالجة الحركة من chessground
  void _handleMove(cg.Move move) {
    final from = _chessgroundSquareToSquare(move.from);
    final to = _chessgroundSquareToSquare(move.to);
    
    // Find the matching legal move
    final legalMoves = controller.getLegalMoves();
    
    for (final legalMove in legalMoves) {
      if (legalMove is NormalMove && 
          legalMove.from == from && 
          legalMove.to == to) {
        
        // Check for promotion
        if (legalMove.promotion != null || _isPromotionMove(from, to)) {
          _showPromotionDialog(from, to);
        } else {
          controller.makeMoveObject(legalMove);
        }
        return;
      }
    }
  }

  /// Check if move requires promotion
  /// التحقق مما إذا كانت الحركة تتطلب ترقية
  bool _isPromotionMove(Square from, Square to) {
    final position = controller.gameState.position;
    final piece = position.board.pieceAt(from);
    
    if (piece == null || piece.role != Role.pawn) return false;
    
    final toRank = to.rank;
    return (piece.color == Side.white && toRank == 7) ||
           (piece.color == Side.black && toRank == 0);
  }

  /// Show promotion dialog
  /// عرض مربع حوار الترقية
  void _showPromotionDialog(Square from, Square to) {
    final side = controller.currentTurn;
    
    Get.dialog(
      AlertDialog(
        title: const Text('Choose Promotion Piece'),
        content: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            _buildPromotionPiece(Role.queen, side, from, to),
            _buildPromotionPiece(Role.rook, side, from, to),
            _buildPromotionPiece(Role.bishop, side, from, to),
            _buildPromotionPiece(Role.knight, side, from, to),
          ],
        ),
      ),
      barrierDismissible: false,
    );
  }

  /// Build promotion piece button
  /// بناء زر قطعة الترقية
  Widget _buildPromotionPiece(Role role, Side side, Square from, Square to) {
    final piece = Piece(color: side, role: role);
    
    return InkWell(
      onTap: () {
        Get.back();
        final move = NormalMove(from: from, to: to, promotion: role);
        controller.makeMoveObject(move);
      },
      child: Container(
        width: 60,
        height: 60,
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Center(
          child: Text(
            _getPieceSymbol(piece),
            style: const TextStyle(fontSize: 40),
          ),
        ),
      ),
    );
  }

  /// Get piece unicode symbol
  /// الحصول على رمز يونيكود للقطعة
  String _getPieceSymbol(Piece piece) {
    const whiteSymbols = {
      Role.queen: '♕',
      Role.rook: '♖',
      Role.bishop: '♗',
      Role.knight: '♘',
    };
    
    const blackSymbols = {
      Role.queen: '♛',
      Role.rook: '♜',
      Role.bishop: '♝',
      Role.knight: '♞',
    };
    
    final symbols = piece.color == Side.white ? whiteSymbols : blackSymbols;
    return symbols[piece.role] ?? '';
  }

  /// Convert dartchess Square to chessground square string
  /// تحويل Square من dartchess إلى نص مربع chessground
  String _squareToChessgroundSquare(Square square) {
    const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
    return '${files[square.file]}${square.rank + 1}';
  }

  /// Convert chessground square string to dartchess Square
  /// تحويل نص مربع chessground إلى Square من dartchess
  Square _chessgroundSquareToSquare(String square) {
    final file = square.codeUnitAt(0) - 'a'.codeUnitAt(0);
    final rank = int.parse(square[1]) - 1;
    return Square.fromCoords(file: file, rank: rank);
  }

  /// Show settings dialog
  /// عرض مربع حوار الإعدادات
  void _showSettingsDialog(BuildContext context) {
    Get.dialog(
      AlertDialog(
        title: const Text('Game Settings'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Obx(() => SwitchListTile(
              title: const Text('Auto-save'),
              subtitle: const Text('Automatically save after each move'),
              value: controller.autoSaveEnabled,
              onChanged: (value) {
                controller.autoSaveEnabled = value;
              },
            )),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Close'),
          ),
        ],
      ),
    );
  }

  /// Handle menu actions
  /// معالجة إجراءات القائمة
  void _handleMenuAction(String action, BuildContext context) {
    switch (action) {
      case 'new_game':
        _confirmNewGame(context);
        break;
      case 'resign':
        _confirmResign(context);
        break;
      case 'draw':
        _confirmDraw(context);
        break;
      case 'export_pgn':
        _exportPgn();
        break;
    }
  }

  /// Confirm new game
  /// تأكيد لعبة جديدة
  void _confirmNewGame(BuildContext context) {
    Get.dialog(
      AlertDialog(
        title: const Text('Start New Game'),
        content: const Text('Are you sure you want to start a new game? Current game will be saved.'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              Get.offNamed('/new-game');
            },
            child: const Text('New Game'),
          ),
        ],
      ),
    );
  }

  /// Confirm resign
  /// تأكيد الاستسلام
  void _confirmResign(BuildContext context) {
    Get.dialog(
      AlertDialog(
        title: const Text('Resign'),
        content: Text('Are you sure ${controller.currentTurn == Side.white ? 'White' : 'Black'} wants to resign?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              controller.resign(controller.currentTurn);
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('Resign'),
          ),
        ],
      ),
    );
  }

  /// Confirm draw
  /// تأكيد التعادل
  void _confirmDraw(BuildContext context) {
    Get.dialog(
      AlertDialog(
        title: const Text('Offer Draw'),
        content: const Text('Do both players agree to a draw?'),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Get.back();
              controller.agreeDrawn();
            },
            child: const Text('Agree Draw'),
          ),
        ],
      ),
    );
  }

  /// Export PGN
  /// تصدير PGN
  void _exportPgn() {
    final pgn = controller.getPgnString();
    
    Get.dialog(
      AlertDialog(
        title: const Text('Export PGN'),
        content: SingleChildScrollView(
          child: SelectableText(pgn),
        ),
        actions: [
          TextButton(
            onPressed: () => Get.back(),
            child: const Text('Close'),
          ),
          ElevatedButton(
            onPressed: () {
              // Copy to clipboard logic here
              Get.back();
              Get.snackbar(
                'PGN Copied',
                'PGN copied to clipboard',
                snackPosition: SnackPosition.BOTTOM,
              );
            },
            child: const Text('Copy'),
          ),
        ],
      ),
    );
  }
}
اكمل للجزء الثامن (Remaining Widgets)